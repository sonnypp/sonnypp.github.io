<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sonnypp</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-01T03:42:08.466Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SUE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#学习之路(20)</title>
    <link href="http://yoursite.com/2018/07/01/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-20/"/>
    <id>http://yoursite.com/2018/07/01/C-学习之路-20/</id>
    <published>2018-07-01T02:27:21.000Z</published>
    <updated>2018-07-01T03:42:08.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-委托（Delegate）"><a href="#C-委托（Delegate）" class="headerlink" title="C#委托（Delegate）"></a>C#委托（Delegate）</h1><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p><h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><p>例如，假设有一个委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int MyDelegate (string s);</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <em>string</em> 参数的方法，并返回一个 <em>int</em> 类型变量。</p><p>声明委托的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span><br></pre></td></tr></table></figure><h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate void printString(string s);</span><br><span class="line">...</span><br><span class="line">printString ps1 = new printString(WriteToScreen);</span><br><span class="line">printString ps2 = new printString(WriteToFile);</span><br></pre></td></tr></table></figure><p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n);</span><br><span class="line"></span><br><span class="line">namespace DelegateApp1</span><br><span class="line">&#123;</span><br><span class="line">    class TestDelegate</span><br><span class="line">    &#123;</span><br><span class="line">        static int num = 10;</span><br><span class="line">        public static int AddNum(int p)</span><br><span class="line">        &#123;</span><br><span class="line">            num+=p;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public static int MultNum(int q)</span><br><span class="line">        &#123;</span><br><span class="line">            num *= q;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        public static int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //创建委托实例</span><br><span class="line">            NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = new NumberChanger(MultNum);</span><br><span class="line">            //使用委托对象调用方法</span><br><span class="line">            nc1(25);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num:&#123;0&#125;&quot;,getNum());</span><br><span class="line">            nc2(5);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num:&#123;0&#125;&quot;,getNum());</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 35</span><br><span class="line">Value of Num: 175</span><br></pre></td></tr></table></figure><h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。下面的程序演示了委托的多播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">delegate int NumberChanger(int n);</span><br><span class="line">namespace DelegateApp1</span><br><span class="line">&#123;</span><br><span class="line">    class TestDelegate</span><br><span class="line">    &#123;</span><br><span class="line">        static int num = 10;</span><br><span class="line">        public static int AddNum(int p)</span><br><span class="line">        &#123;</span><br><span class="line">            num+=p;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        public static int MultNum(int q)</span><br><span class="line">        &#123;</span><br><span class="line">            num*=q;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        public static int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = new NumberChanger(MultNum);</span><br><span class="line">            nc = nc1;</span><br><span class="line">            nc += nc2;</span><br><span class="line">            //调用多播</span><br><span class="line">            nc(5);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num:&#123;0&#125;&quot;,getNum());</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 75</span><br></pre></td></tr></table></figure><h2 id="委托（Delegate）的用途"><a href="#委托（Delegate）的用途" class="headerlink" title="委托（Delegate）的用途"></a>委托（Delegate）的用途</h2><p>下面的实例演示了委托的用法。委托 <em>printString</em> 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p><p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">   class PrintString</span><br><span class="line">   &#123;</span><br><span class="line">      static FileStream fs;</span><br><span class="line">      static StreamWriter sw;</span><br><span class="line">      // 委托声明</span><br><span class="line">      public delegate void printString(string s);</span><br><span class="line"></span><br><span class="line">      // 该方法打印到控制台</span><br><span class="line">      public static void WriteToScreen(string str)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);</span><br><span class="line">      &#125;</span><br><span class="line">      // 该方法打印到文件</span><br><span class="line">      public static void WriteToFile(string s)</span><br><span class="line">      &#123;</span><br><span class="line">         fs = new FileStream(&quot;d:\\test.txt&quot;,</span><br><span class="line">         FileMode.Append, FileAccess.Write);</span><br><span class="line">         sw = new StreamWriter(fs);</span><br><span class="line">         sw.WriteLine(s);</span><br><span class="line">         sw.Flush();</span><br><span class="line">         sw.Close();</span><br><span class="line">         fs.Close();</span><br><span class="line">      &#125;</span><br><span class="line">      // 该方法把委托作为参数，并使用它调用方法</span><br><span class="line">      public static void sendString(printString ps)</span><br><span class="line">      &#123;</span><br><span class="line">         ps(&quot;Hello World&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         printString ps1 = new printString(WriteToScreen);</span><br><span class="line">         printString ps2 = new printString(WriteToFile);</span><br><span class="line">         sendString(ps1);</span><br><span class="line">         sendString(ps2);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The String is: Hello World</span><br></pre></td></tr></table></figure><h1 id="C-事件（Event）"><a href="#C-事件（Event）" class="headerlink" title="C# 事件（Event）"></a>C# 事件（Event）</h1><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些出现，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。事件是用于进程间通信。 </p><h2 id="通过事件使用委托"><a href="#通过事件使用委托" class="headerlink" title="通过事件使用委托"></a>通过事件使用委托</h2><p>事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p><h2 id="声明事件（Event）"><a href="#声明事件（Event）" class="headerlink" title="声明事件（Event）"></a>声明事件（Event）</h2><p>在类的内部声明事件，首先必须声明该事件的委托类型。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate void BoilerLogHandler(string status);</span><br></pre></td></tr></table></figure><p>然后，声明事件本身，使用关键字<strong>event</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//基于上面的委托定义事件</span><br><span class="line">public event BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为 <em>BoilerLogHandler</em> 的委托和一个名为 <em>BoilerEventLog</em> 的事件，该事件在生成的时候会调用委托。 </p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace SimpleEvent</span><br><span class="line">&#123;</span><br><span class="line">    using System;</span><br><span class="line">    //发布器类</span><br><span class="line">    public class EventTest</span><br><span class="line">    &#123;</span><br><span class="line">        private int value;</span><br><span class="line">        public delegate void NumManipulationHandler();</span><br><span class="line">        </span><br><span class="line">        public event NumManipulationHandler ChangeNum;</span><br><span class="line">        protected virtual void OnNumChanged()</span><br><span class="line">        &#123;</span><br><span class="line">            if( ChangeNum!=null )</span><br><span class="line">            &#123;</span><br><span class="line">                ChangeNum();  //事件触发</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Console.WriteLine(&quot;event not fire&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public EventTest()</span><br><span class="line">        &#123;</span><br><span class="line">            int n=5;</span><br><span class="line">            SetValue(n);</span><br><span class="line">        &#125;</span><br><span class="line">        public void SetValue(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if(value!=n) &#123;</span><br><span class="line">                value =n;</span><br><span class="line">                OnNumChanged();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //订阅器类</span><br><span class="line">    public class subscribEvent</span><br><span class="line">    &#123;</span><br><span class="line">        public void printf()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;event fire&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //触发</span><br><span class="line">    public class MainClass</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            EventTest e = new EventTest() ;//实例化对象。第一次没有触发事件</span><br><span class="line">            subscribEvent v = new subscribEvent();//实例化对象</span><br><span class="line">            e.ChangeNum +=  new EventTest.NumManipulationHandler( v.printf ); /* 注册 */</span><br><span class="line">            e.SetValue( 7 );</span><br><span class="line">          e.SetValue( 11 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h2><p>本实例提供一个简单的用于热水锅炉系统故障排除的应用程序。当维修工程师检查锅炉时，锅炉的温度和压力会随着维修工程师的备注自动记录到日志文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace BoilerEventAppl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   // boiler 类</span><br><span class="line">   class Boiler</span><br><span class="line">   &#123;</span><br><span class="line">      private int temp;</span><br><span class="line">      private int pressure;</span><br><span class="line">      public Boiler(int t, int p)</span><br><span class="line">      &#123;</span><br><span class="line">         temp = t;</span><br><span class="line">         pressure = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public int getTemp()</span><br><span class="line">      &#123;</span><br><span class="line">         return temp;</span><br><span class="line">      &#125;</span><br><span class="line">      public int getPressure()</span><br><span class="line">      &#123;</span><br><span class="line">         return pressure;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 事件发布器</span><br><span class="line">   class DelegateBoilerEvent</span><br><span class="line">   &#123;</span><br><span class="line">      public delegate void BoilerLogHandler(string status);</span><br><span class="line"></span><br><span class="line">      // 基于上面的委托定义事件</span><br><span class="line">      public event BoilerLogHandler BoilerEventLog;</span><br><span class="line"></span><br><span class="line">      public void LogProcess()</span><br><span class="line">      &#123;</span><br><span class="line">         string remarks = &quot;O. K&quot;;</span><br><span class="line">         Boiler b = new Boiler(100, 12);</span><br><span class="line">         int t = b.getTemp();</span><br><span class="line">         int p = b.getPressure();</span><br><span class="line">         if(t &gt; 150 || t &lt; 80 || p &lt; 12 || p &gt; 15)</span><br><span class="line">         &#123;</span><br><span class="line">            remarks = &quot;Need Maintenance&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">         OnBoilerEventLog(&quot;Logging Info:\n&quot;);</span><br><span class="line">         OnBoilerEventLog(&quot;Temparature &quot; + t + &quot;\nPressure: &quot; + p);</span><br><span class="line">         OnBoilerEventLog(&quot;\nMessage: &quot; + remarks);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      protected void OnBoilerEventLog(string message)</span><br><span class="line">      &#123;</span><br><span class="line">         if (BoilerEventLog != null)</span><br><span class="line">         &#123;</span><br><span class="line">            BoilerEventLog(message);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 该类保留写入日志文件的条款</span><br><span class="line">   class BoilerInfoLogger</span><br><span class="line">   &#123;</span><br><span class="line">      FileStream fs;</span><br><span class="line">      StreamWriter sw;</span><br><span class="line">      public BoilerInfoLogger(string filename)</span><br><span class="line">      &#123;</span><br><span class="line">         fs = new FileStream(filename, FileMode.Append, FileAccess.Write);</span><br><span class="line">         sw = new StreamWriter(fs);</span><br><span class="line">      &#125;</span><br><span class="line">      public void Logger(string info)</span><br><span class="line">      &#123;</span><br><span class="line">         sw.WriteLine(info);</span><br><span class="line">      &#125;</span><br><span class="line">      public void Close()</span><br><span class="line">      &#123;</span><br><span class="line">         sw.Close();</span><br><span class="line">         fs.Close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 事件订阅器</span><br><span class="line">   public class RecordBoilerInfo</span><br><span class="line">   &#123;</span><br><span class="line">      static void Logger(string info)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(info);</span><br><span class="line">      &#125;//end of Logger</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         BoilerInfoLogger filelog = new BoilerInfoLogger(&quot;d:\\test.txt&quot;);</span><br><span class="line">         DelegateBoilerEvent boilerEvent = new DelegateBoilerEvent();</span><br><span class="line">         boilerEvent.BoilerEventLog += new </span><br><span class="line">         DelegateBoilerEvent.BoilerLogHandler(Logger);</span><br><span class="line">         boilerEvent.BoilerEventLog += new </span><br><span class="line">         DelegateBoilerEvent.BoilerLogHandler(filelog.Logger);</span><br><span class="line">         boilerEvent.LogProcess();</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">         filelog.Close();</span><br><span class="line">      &#125;//end of main</span><br><span class="line"></span><br><span class="line">   &#125;//end of RecordBoilerInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logging info:</span><br><span class="line"></span><br><span class="line">Temperature 100</span><br><span class="line">Pressure 12</span><br><span class="line"></span><br><span class="line">Message: O. K</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-委托（Delegate）&quot;&gt;&lt;a href=&quot;#C-委托（Delegate）&quot; class=&quot;headerlink&quot; title=&quot;C#委托（Delegate）&quot;&gt;&lt;/a&gt;C#委托（Delegate）&lt;/h1&gt;&lt;p&gt;C# 中的委托（Delegate）类似于 C
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(19)</title>
    <link href="http://yoursite.com/2018/07/01/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-19/"/>
    <id>http://yoursite.com/2018/07/01/C-学习之路-19/</id>
    <published>2018-07-01T01:26:19.000Z</published>
    <updated>2018-07-01T02:27:11.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-反射（Reflection）"><a href="#C-反射（Reflection）" class="headerlink" title="C# 反射（Reflection）"></a>C# 反射（Reflection）</h1><p>反射指程序可以访问、检测和修改它本身状态或行为的一种能力。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型对象。</p><p>您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ul><li>1、反射提高了程序的灵活性和扩展性。</li><li>2、降低耦合性，提高自适应能力。</li><li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ul><p>缺点</p><ul><li>1、性能问题：使用反射基本是一种解释操作。用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用。</li><li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ul><h2 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h2><p>反射有下列用途：</p><ul><li>它允许在运行时查看特性信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>我们已经在上面的章节中提到过，使用反射可以查看特性信息。</p><p>System.Reflection类的MemberInfo对象需要被初始化，用于发现与类相关的特性。为了做到这点，您可以定义目标类的一个对象，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = typeof(MyClass);</span><br></pre></td></tr></table></figure><p>下面程序演示了这点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">[AttributeUsage(AttributeTargets.All)]</span><br><span class="line">public class HelpAttribute:System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">public readonly string Url;</span><br><span class="line">public string Topic</span><br><span class="line">    &#123;</span><br><span class="line">    get</span><br><span class="line">        &#123;</span><br><span class="line">        return topic;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">        topic = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public HelpAttribute(string url)</span><br><span class="line">    &#123;</span><br><span class="line">    this.Url = url; </span><br><span class="line">    &#125;</span><br><span class="line">    private string topic;</span><br><span class="line">&#125;</span><br><span class="line">[HelpAttribute(&quot;Information on the class Myclass&quot;)]</span><br><span class="line">class Myclass</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">namespace AttributeApp1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            System.Reflection.MemberInfo info = typeof(Myclass);</span><br><span class="line">            object[] atrributes = info.GetCustomAttributes(true);</span><br><span class="line">            for(int i=0;i&lt;atrributes.Length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(atrributes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会显示附加到类 <em>Myclass</em> 上的自定义特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelpAttribute</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在本实例中，我们将使用在上一章中创建的DeBugInfo特性，并使用反射来读取Rectangle类中的元数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Reflection;</span><br><span class="line">namespace BugFixApplication</span><br><span class="line">&#123;</span><br><span class="line">    // 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">   [AttributeUsage(AttributeTargets.Class |</span><br><span class="line">   AttributeTargets.Constructor |</span><br><span class="line">   AttributeTargets.Field |</span><br><span class="line">   AttributeTargets.Method |</span><br><span class="line">   AttributeTargets.Property,</span><br><span class="line">   AllowMultiple = true)]</span><br><span class="line">   </span><br><span class="line">    public class DeBugInfo:System.Attribute</span><br><span class="line">    &#123;</span><br><span class="line">    private int bugNo;</span><br><span class="line">    private string developer;</span><br><span class="line">    private string lastReview;</span><br><span class="line">    private string message;</span><br><span class="line">    </span><br><span class="line">    public DeBugInfo(int bg,string dev,string d)</span><br><span class="line">        &#123;</span><br><span class="line">        this.bugNo = bg;</span><br><span class="line">        this.developer = dev;</span><br><span class="line">        this.lastReview = d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public int BugNo</span><br><span class="line">        &#123;</span><br><span class="line">        get</span><br><span class="line">            &#123;</span><br><span class="line">            return bugNo;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">          public string Developer</span><br><span class="line">          &#123;</span><br><span class="line">             get</span><br><span class="line">             &#123;</span><br><span class="line">                return developer;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public string LastReview</span><br><span class="line">          &#123;</span><br><span class="line">             get</span><br><span class="line">             &#123;</span><br><span class="line">                return lastReview;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public string Message</span><br><span class="line">          &#123;</span><br><span class="line">             get</span><br><span class="line">             &#123;</span><br><span class="line">                return message;</span><br><span class="line">             &#125;</span><br><span class="line">             set</span><br><span class="line">             &#123;</span><br><span class="line">                message = value;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   [DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;,</span><br><span class="line">    Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">   [DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;,</span><br><span class="line">    Message = &quot;Unused variable&quot;)]</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">         // 成员变量</span><br><span class="line">      protected double length;</span><br><span class="line">      protected double width;</span><br><span class="line">      public Rectangle(double l, double w)</span><br><span class="line">      &#123;</span><br><span class="line">         length = l;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;,</span><br><span class="line">       Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">      public double GetArea()</span><br><span class="line">      &#123;</span><br><span class="line">         return length * width;</span><br><span class="line">      &#125;</span><br><span class="line">      [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]</span><br><span class="line">      public void Display()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);</span><br><span class="line">         Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);</span><br><span class="line">         Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">             Rectangle r = new Rectangle(4.5, 7.5);</span><br><span class="line">          r.Display();</span><br><span class="line">             Type type = typeof(Rectangle);</span><br><span class="line">             // 遍历 Rectangle 类的特性</span><br><span class="line">             foreach (Object attributes in type.GetCustomAttributes(false))</span><br><span class="line">             &#123;</span><br><span class="line">                DeBugInfo dbi = (DeBugInfo)attributes;</span><br><span class="line">                if (null != dbi)</span><br><span class="line">                &#123;</span><br><span class="line">                   Console.WriteLine(&quot;Bug no: &#123;0&#125;&quot;, dbi.BugNo);</span><br><span class="line">                   Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);</span><br><span class="line">                   Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;,</span><br><span class="line">                        dbi.LastReview);</span><br><span class="line">                   Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                 // 遍历方法特性</span><br><span class="line">             foreach (MethodInfo m in type.GetMethods())</span><br><span class="line">             &#123;</span><br><span class="line">                foreach (Attribute a in m.GetCustomAttributes(true))</span><br><span class="line">                &#123;</span><br><span class="line">                   DeBugInfo dbi = (DeBugInfo)a;</span><br><span class="line">                   if (null != dbi)</span><br><span class="line">                   &#123;</span><br><span class="line">                      Console.WriteLine(&quot;Bug no: &#123;0&#125;, for Method: &#123;1&#125;&quot;,</span><br><span class="line">                            dbi.BugNo, m.Name);</span><br><span class="line">                      Console.WriteLine(&quot;Developer: &#123;0&#125;&quot;, dbi.Developer);</span><br><span class="line">                      Console.WriteLine(&quot;Last Reviewed: &#123;0&#125;&quot;,</span><br><span class="line">                            dbi.LastReview);</span><br><span class="line">                      Console.WriteLine(&quot;Remarks: &#123;0&#125;&quot;, dbi.Message);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Length: 4.5</span><br><span class="line">Width: 7.5</span><br><span class="line">Area: 33.75</span><br><span class="line">Bug No: 49</span><br><span class="line">Developer: Nuha Ali</span><br><span class="line">Last Reviewed: 10/10/2012</span><br><span class="line">Remarks: Unused variable</span><br><span class="line">Bug No: 45</span><br><span class="line">Developer: Zara Ali</span><br><span class="line">Last Reviewed: 12/8/2012</span><br><span class="line">Remarks: Return type mismatch</span><br><span class="line">Bug No: 55, for Method: GetArea</span><br><span class="line">Developer: Zara Ali</span><br><span class="line">Last Reviewed: 19/10/2012</span><br><span class="line">Remarks: Return type mismatch</span><br><span class="line">Bug No: 56, for Method: Display</span><br><span class="line">Developer: Zara Ali</span><br><span class="line">Last Reviewed: 19/10/2012</span><br><span class="line">Remarks:</span><br></pre></td></tr></table></figure><h1 id="C-属性（Property）"><a href="#C-属性（Property）" class="headerlink" title="C# 属性（Property）"></a>C# 属性（Property）</h1><p><strong>属性（Property）</strong> 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 <strong>域（Field）</strong>。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p><p>属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 <strong>访问器（accessors）</strong>。</p><p>例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。</p><h2 id="访问器（Accessors）"><a href="#访问器（Accessors）" class="headerlink" title="访问器（Accessors）"></a>访问器（Accessors）</h2><p>属性（Property）的<strong>访问器（accessor）</strong>包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 声明类型为 string 的 Code 属性</span><br><span class="line">public string Code</span><br><span class="line">&#123;</span><br><span class="line">   get</span><br><span class="line">   &#123;</span><br><span class="line">      return code;</span><br><span class="line">   &#125;</span><br><span class="line">   set</span><br><span class="line">   &#123;</span><br><span class="line">      code = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明类型为 string 的 Name 属性</span><br><span class="line">public string Name</span><br><span class="line">&#123;</span><br><span class="line">   get</span><br><span class="line">   &#123;</span><br><span class="line">     return name;</span><br><span class="line">   &#125;</span><br><span class="line">   set</span><br><span class="line">   &#123;</span><br><span class="line">     name = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明类型为 int 的 Age 属性</span><br><span class="line">public int Age</span><br><span class="line">&#123; </span><br><span class="line">   get</span><br><span class="line">   &#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line">   set</span><br><span class="line">   &#123;</span><br><span class="line">      age = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了属性（Property）的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace tutorialspoint</span><br><span class="line">&#123;</span><br><span class="line">   class Student</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      private string code = &quot;N.A&quot;;</span><br><span class="line">      private string name = &quot;not known&quot;;</span><br><span class="line">      private int age = 0;</span><br><span class="line"></span><br><span class="line">      // 声明类型为 string 的 Code 属性</span><br><span class="line">      public string Code</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return code;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            code = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      // 声明类型为 string 的 Name 属性</span><br><span class="line">      public string Name</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return name;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            name = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 声明类型为 int 的 Age 属性</span><br><span class="line">      public int Age</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return age;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            age = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public override string ToString()</span><br><span class="line">      &#123;</span><br><span class="line">         return &quot;Code = &quot; + Code +&quot;, Name = &quot; + Name + &quot;, Age = &quot; + Age;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ExampleDemo</span><br><span class="line">    &#123;</span><br><span class="line">      public static void Main()</span><br><span class="line">      &#123;</span><br><span class="line">         // 创建一个新的 Student 对象</span><br><span class="line">         Student s = new Student();</span><br><span class="line">            </span><br><span class="line">         // 设置 student 的 code、name 和 age</span><br><span class="line">         s.Code = &quot;001&quot;;</span><br><span class="line">         s.Name = &quot;Zara&quot;;</span><br><span class="line">         s.Age = 9;</span><br><span class="line">         Console.WriteLine(&quot;Student Info: &#123;0&#125;&quot;, s);</span><br><span class="line">         // 增加年龄</span><br><span class="line">         s.Age += 1;</span><br><span class="line">         Console.WriteLine(&quot;Student Info: &#123;0&#125;&quot;, s);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student Info: Code = 001, Name = Zara, Age = 9</span><br><span class="line">Student Info: Code = 001, Name = Zara, Age = 10</span><br></pre></td></tr></table></figure><h2 id="抽象属性（Abstract-Properties）"><a href="#抽象属性（Abstract-Properties）" class="headerlink" title="抽象属性（Abstract Properties）"></a>抽象属性（Abstract Properties）</h2><p>抽象类可拥有抽象属性，这些属性应在派生类中被实现。下面的程序说明了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace tutorialspoint</span><br><span class="line">&#123;</span><br><span class="line">   public abstract class Person</span><br><span class="line">   &#123;</span><br><span class="line">      public abstract string Name</span><br><span class="line">      &#123;</span><br><span class="line">         get;</span><br><span class="line">         set;</span><br><span class="line">      &#125;</span><br><span class="line">      public abstract int Age</span><br><span class="line">      &#123;</span><br><span class="line">         get;</span><br><span class="line">         set;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Student : Person</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      private string code = &quot;N.A&quot;;</span><br><span class="line">      private string name = &quot;N.A&quot;;</span><br><span class="line">      private int age = 0;</span><br><span class="line"></span><br><span class="line">      // 声明类型为 string 的 Code 属性</span><br><span class="line">      public string Code</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return code;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            code = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      // 声明类型为 string 的 Name 属性</span><br><span class="line">      public override string Name</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return name;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            name = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 声明类型为 int 的 Age 属性</span><br><span class="line">      public override int Age</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            return age;</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            age = value;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public override string ToString()</span><br><span class="line">      &#123;</span><br><span class="line">         return &quot;Code = &quot; + Code +&quot;, Name = &quot; + Name + &quot;, Age = &quot; + Age;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class ExampleDemo</span><br><span class="line">   &#123;</span><br><span class="line">      public static void Main()</span><br><span class="line">      &#123;</span><br><span class="line">         // 创建一个新的 Student 对象</span><br><span class="line">         Student s = new Student();</span><br><span class="line">            </span><br><span class="line">         // 设置 student 的 code、name 和 age</span><br><span class="line">         s.Code = &quot;001&quot;;</span><br><span class="line">         s.Name = &quot;Zara&quot;;</span><br><span class="line">         s.Age = 9;</span><br><span class="line">         Console.WriteLine(&quot;Student Info:- &#123;0&#125;&quot;, s);</span><br><span class="line">         // 增加年龄</span><br><span class="line">         s.Age += 1;</span><br><span class="line">         Console.WriteLine(&quot;Student Info:- &#123;0&#125;&quot;, s);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student Info: Code = 001, Name = Zara, Age = 9</span><br><span class="line">Student Info: Code = 001, Name = Zara, Age = 10</span><br></pre></td></tr></table></figure><h1 id="C-索引器（Indexer）"><a href="#C-索引器（Indexer）" class="headerlink" title="C# 索引器（Indexer）"></a>C# 索引器（Indexer）</h1><p><strong>索引器（Indexer）</strong> 允许一个对象可以像数组一样被索引。当您为类定义一个索引器时，该类的行为就会像一个 <strong>虚拟数组（virtual array）</strong> 一样。您可以使用数组访问运算符（[ ]）来访问该类的实例。 </p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>一维索引器的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">element-type this[int index] </span><br><span class="line">&#123;</span><br><span class="line">   // get 访问器</span><br><span class="line">   get </span><br><span class="line">   &#123;</span><br><span class="line">      // 返回 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // set 访问器</span><br><span class="line">   set </span><br><span class="line">   &#123;</span><br><span class="line">      // 设置 index 指定的值 </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器（Indexer）的用途"><a href="#索引器（Indexer）的用途" class="headerlink" title="索引器（Indexer）的用途"></a>索引器（Indexer）的用途</h2><p>索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），您可使用 <strong>get</strong> 和 <strong>set</strong> 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。</p><p>定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 <strong>this</strong> 关键字，它指向对象实例。下面的实例演示了这个概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace IndexerApplication</span><br><span class="line">&#123;</span><br><span class="line">   class IndexedNames</span><br><span class="line">   &#123;</span><br><span class="line">      private string[] namelist = new string[size];</span><br><span class="line">      static public int size = 10;</span><br><span class="line">      public IndexedNames()</span><br><span class="line">      &#123;</span><br><span class="line">         for (int i = 0; i &lt; size; i++)</span><br><span class="line">         namelist[i] = &quot;N. A.&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      public string this[int index]</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            string tmp;</span><br><span class="line"></span><br><span class="line">            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )</span><br><span class="line">            &#123;</span><br><span class="line">               tmp = namelist[index];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               tmp = &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return ( tmp );</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )</span><br><span class="line">            &#123;</span><br><span class="line">               namelist[index] = value;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         IndexedNames names = new IndexedNames();</span><br><span class="line">         names[0] = &quot;Zara&quot;;</span><br><span class="line">         names[1] = &quot;Riz&quot;;</span><br><span class="line">         names[2] = &quot;Nuha&quot;;</span><br><span class="line">         names[3] = &quot;Asif&quot;;</span><br><span class="line">         names[4] = &quot;Davinder&quot;;</span><br><span class="line">         names[5] = &quot;Sunil&quot;;</span><br><span class="line">         names[6] = &quot;Rubic&quot;;</span><br><span class="line">         for ( int i = 0; i &lt; IndexedNames.size; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(names[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Zara</span><br><span class="line">Riz</span><br><span class="line">Nuha</span><br><span class="line">Asif</span><br><span class="line">Davinder</span><br><span class="line">Sunil</span><br><span class="line">Rubic</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br></pre></td></tr></table></figure><h2 id="重载索引器（Indexer）"><a href="#重载索引器（Indexer）" class="headerlink" title="重载索引器（Indexer）"></a>重载索引器（Indexer）</h2><p>索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。没有必要让索引器必须是整型的。C# 允许索引器可以是其他类型，例如，字符串类型。</p><p>下面的实例演示了重载索引器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace IndexerApplication</span><br><span class="line">&#123;</span><br><span class="line">   class IndexedNames</span><br><span class="line">   &#123;</span><br><span class="line">      private string[] namelist = new string[size];</span><br><span class="line">      static public int size = 10;</span><br><span class="line">      public IndexedNames()</span><br><span class="line">      &#123;</span><br><span class="line">         for (int i = 0; i &lt; size; i++)</span><br><span class="line">         &#123;</span><br><span class="line">          namelist[i] = &quot;N. A.&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public string this[int index]</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            string tmp;</span><br><span class="line"></span><br><span class="line">            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )</span><br><span class="line">            &#123;</span><br><span class="line">               tmp = namelist[index];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               tmp = &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return ( tmp );</span><br><span class="line">         &#125;</span><br><span class="line">         set</span><br><span class="line">         &#123;</span><br><span class="line">            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )</span><br><span class="line">            &#123;</span><br><span class="line">               namelist[index] = value;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public int this[string name]</span><br><span class="line">      &#123;</span><br><span class="line">         get</span><br><span class="line">         &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while(index &lt; size)</span><br><span class="line">            &#123;</span><br><span class="line">               if (namelist[index] == name)</span><br><span class="line">               &#123;</span><br><span class="line">                return index;</span><br><span class="line">               &#125;</span><br><span class="line">               index++;</span><br><span class="line">            &#125;</span><br><span class="line">            return index;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         IndexedNames names = new IndexedNames();</span><br><span class="line">         names[0] = &quot;Zara&quot;;</span><br><span class="line">         names[1] = &quot;Riz&quot;;</span><br><span class="line">         names[2] = &quot;Nuha&quot;;</span><br><span class="line">         names[3] = &quot;Asif&quot;;</span><br><span class="line">         names[4] = &quot;Davinder&quot;;</span><br><span class="line">         names[5] = &quot;Sunil&quot;;</span><br><span class="line">         names[6] = &quot;Rubic&quot;;</span><br><span class="line">         // 使用带有 int 参数的第一个索引器</span><br><span class="line">         for (int i = 0; i &lt; IndexedNames.size; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(names[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         // 使用带有 string 参数的第二个索引器</span><br><span class="line">         Console.WriteLine(names[&quot;Nuha&quot;]);</span><br><span class="line">         Console.ReadLinew();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Zara</span><br><span class="line">Riz</span><br><span class="line">Nuha</span><br><span class="line">Asif</span><br><span class="line">Davinder</span><br><span class="line">Sunil</span><br><span class="line">Rubic</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br><span class="line">2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-反射（Reflection）&quot;&gt;&lt;a href=&quot;#C-反射（Reflection）&quot; class=&quot;headerlink&quot; title=&quot;C# 反射（Reflection）&quot;&gt;&lt;/a&gt;C# 反射（Reflection）&lt;/h1&gt;&lt;p&gt;反射指程序可以访问、检测
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(18)</title>
    <link href="http://yoursite.com/2018/07/01/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-18/"/>
    <id>http://yoursite.com/2018/07/01/C-学习之路-18/</id>
    <published>2018-07-01T01:06:54.000Z</published>
    <updated>2018-07-01T01:25:48.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-特性"><a href="#C-特性" class="headerlink" title="C#特性"></a>C#特性</h1><p><strong>特性 </strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性消息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[]）来描述的。</p><p>特性用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net框架提供了两种类型的特性：预定义特性和自定义特性。</p><h2 id="规定特性"><a href="#规定特性" class="headerlink" title="规定特性"></a>规定特性</h2><p>规定特性的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[attribute(positional_parameters, name_parameter = value, ...)]</span><br><span class="line">element</span><br></pre></td></tr></table></figure><p>特性的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters规定必需的信息，name_parameter规定可选的信息。</p><h2 id="预定义特性（Attribute）"><a href="#预定义特性（Attribute）" class="headerlink" title="预定义特性（Attribute）"></a>预定义特性（Attribute）</h2><p>.Net 框架提供了三种预定义特性：</p><ul><li>AttributeUsage</li><li>Conditional</li><li>Obsolete</li></ul><h3 id="AttributeUsage"><a href="#AttributeUsage" class="headerlink" title="AttributeUsage"></a>AttributeUsage</h3><h3 id="AttributeUsage-1"><a href="#AttributeUsage-1" class="headerlink" title="AttributeUsage"></a>AttributeUsage</h3><p>预定义特性 <strong>AttributeUsage</strong> 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p><p>规定该特性的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(</span><br><span class="line">   validon,</span><br><span class="line">   AllowMultiple=allowmultiple,</span><br><span class="line">   Inherited=inherited</span><br><span class="line">)]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>参数 validon 规定特性可被放置的语言元素。它是枚举器 <em>AttributeTargets</em> 的值的组合。默认值是 <em>AttributeTargets.All</em>。</li><li>参数 <em>allowmultiple</em>（可选的）为该特性的 <em>AllowMultiple</em> 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。</li><li>参数 <em>inherited</em>（可选的）为该特性的 <em>Inherited</em> 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property, </span><br><span class="line">AllowMultiple = true)]</span><br></pre></td></tr></table></figure><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h3><p>这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符。</p><p>它会引起方法调用的条件编译，取决于指定的值，比如 <strong>Debug</strong> 或 <strong>Trace</strong>。例如，当调试代码时显示变量的值。</p><p>规定该特性的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Conditional(</span><br><span class="line">   conditionalSymbol</span><br><span class="line">)]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Conditional(&quot;DEBUG&quot;)]</span><br></pre></td></tr></table></figure><p>下面的实例演示了该特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br><span class="line">using System;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">public class Myclass</span><br><span class="line">&#123;</span><br><span class="line">    [Conditional(&quot;DEBUG&quot;)]</span><br><span class="line">    public static void Message(string msg)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void function1()</span><br><span class="line">    &#123;</span><br><span class="line">        Myclass.Message(&quot;In Function 1.&quot;);</span><br><span class="line">        function2();</span><br><span class="line">    &#125;</span><br><span class="line">    static void function2()</span><br><span class="line">    &#123;</span><br><span class="line">        Myclass.Message(&quot;In Function 2.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Myclass.Message(&quot;In Main function.&quot;);</span><br><span class="line">        function1();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main function</span><br><span class="line">In Function 1</span><br><span class="line">In Function 2</span><br></pre></td></tr></table></figure><h3 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a>Obsolete</h3><p>这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p><p>规定该特性的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Obsolete(</span><br><span class="line">   message</span><br><span class="line">)]</span><br><span class="line">[Obsolete(</span><br><span class="line">   message,</span><br><span class="line">   iserror</span><br><span class="line">)]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>参数 <em>message</em>，是一个字符串，描述项目为什么过时的原因以及该替代使用什么。</li><li>参数 <em>iserror</em>，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li></ul><p>下面的实例演示了该特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">   [Obsolete(&quot;Don&apos;t use OldMethod, use NewMethod instead&quot;, true)]</span><br><span class="line">   static void OldMethod()</span><br><span class="line">   &#123; </span><br><span class="line">      Console.WriteLine(&quot;It is the old method&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   static void NewMethod()</span><br><span class="line">   &#123; </span><br><span class="line">      Console.WriteLine(&quot;It is the new method&quot;); </span><br><span class="line">   &#125;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line">      OldMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您尝试编译该程序时，编译器会给出一个错误消息说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Don&apos;t use OldMethod, use NewMethod instead</span><br></pre></td></tr></table></figure><h2 id="创建自定义特性（Attribute）"><a href="#创建自定义特性（Attribute）" class="headerlink" title="创建自定义特性（Attribute）"></a>创建自定义特性（Attribute）</h2><p>.Net 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。</p><p>创建并使用自定义特性包含四个步骤：</p><ul><li>声明自定义特性</li><li>构建自定义特性</li><li>在目标程序元素上应用自定义特性</li><li>通过反射访问特性</li></ul><p>最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。我们将在下一章详细讨论这点。</p><h3 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h3><p>一个新的自定义特性应派生自 <strong>System.Attribute</strong> 类。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们已经声明了一个名为 <em>DeBugInfo</em> 的自定义特性。</p><h3 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h3><p>让我们构建一个名为 <em>DeBugInfo</em> 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：</p><ul><li>bug 的代码编号</li><li>辨认该 bug 的开发人员名字</li><li>最后一次审查该代码的日期</li><li>一个存储了开发人员标记的字符串消息</li></ul><p>我们的 <em>DeBugInfo</em> 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。</p><p>每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 <em>DeBugInfo</em> 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">  private int bugNo;</span><br><span class="line">  private string developer;</span><br><span class="line">  private string lastReview;</span><br><span class="line">  public string message;</span><br><span class="line"></span><br><span class="line">  public DeBugInfo(int bg, string dev, string d)</span><br><span class="line">  &#123;</span><br><span class="line">      this.bugNo = bg;</span><br><span class="line">      this.developer = dev;</span><br><span class="line">      this.lastReview = d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int BugNo</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return bugNo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Developer</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return developer;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string LastReview</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return lastReview;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Message</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return message;</span><br><span class="line">      &#125;</span><br><span class="line">      set</span><br><span class="line">      &#123;</span><br><span class="line">          message = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h3><p>通过把特性放置在紧接着它的目标之前，来应用该特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">[DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]</span><br><span class="line">class Rectangle</span><br><span class="line">&#123;</span><br><span class="line">  // 成员变量</span><br><span class="line">  protected double length;</span><br><span class="line">  protected double width;</span><br><span class="line">  public Rectangle(double l, double w)</span><br><span class="line">  &#123;</span><br><span class="line">      length = l;</span><br><span class="line">      width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;,</span><br><span class="line">  Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">  public double GetArea()</span><br><span class="line">  &#123;</span><br><span class="line">      return length * width;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]</span><br><span class="line">  public void Display()</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);</span><br><span class="line">      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);</span><br><span class="line">      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-特性&quot;&gt;&lt;a href=&quot;#C-特性&quot; class=&quot;headerlink&quot; title=&quot;C#特性&quot;&gt;&lt;/a&gt;C#特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;特性 &lt;/strong&gt;是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(17)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-17/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-17/</id>
    <published>2018-06-26T08:03:10.000Z</published>
    <updated>2018-06-26T08:11:13.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-文件的输入与输出"><a href="#C-文件的输入与输出" class="headerlink" title="C# 文件的输入与输出"></a>C# 文件的输入与输出</h1><p>一个 <strong>文件</strong> 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 <strong>流</strong>。</p><p>从根本上说，流是通过通信路径传递的字节序列。有两个主要的流：<strong>输入流</strong> 和 <strong>输出流</strong>。<strong>输入流</strong>用于从文件读取数据（写操作），<strong>输出流</strong>用于向文件写入数据（读操作）。</p><h2 id="C-I-O-类"><a href="#C-I-O-类" class="headerlink" title="C# I/O 类"></a>C# I/O 类</h2><p>System.IO 命名空间有各种不同的类，用于执行各种文件操作，如创建和删除文件、读取或写入文件，关闭文件等。</p><p>下表列出了一些 System.IO 命名空间中常用的非抽象类：</p><table><thead><tr><th>I/O 类</th><th>描述</th></tr></thead><tbody><tr><td>BinaryReader</td><td>从二进制流读取原始数据。</td></tr><tr><td>BinaryWriter</td><td>以二进制格式写入原始数据。</td></tr><tr><td>BufferedStream</td><td>字节流的临时存储。</td></tr><tr><td>Directory</td><td>有助于操作目录结构。</td></tr><tr><td>DirectoryInfo</td><td>用于对目录执行操作。</td></tr><tr><td>DriveInfo</td><td>提供驱动器的信息。</td></tr><tr><td>File</td><td>有助于处理文件。</td></tr><tr><td>FileInfo</td><td>用于对文件执行操作。</td></tr><tr><td>FileStream</td><td>用于文件中任何位置的读写。</td></tr><tr><td>MemoryStream</td><td>用于随机访问存储在内存中的数据流。</td></tr><tr><td>Path</td><td>对路径信息执行操作。</td></tr><tr><td>StreamReader</td><td>用于从字节流中读取字符。</td></tr><tr><td>StreamWriter</td><td>用于向一个流中写入字符。</td></tr><tr><td>StringReader</td><td>用于读取字符串缓冲区。</td></tr><tr><td>StringWriter</td><td>用于写入字符串缓冲区。</td></tr></tbody></table><p>System.IO 命名空间中的 <strong>FileStream</strong> 类有助于文件的读写与关闭。该类派生自抽象类 Stream。</p><p>您需要创建一个 <strong>FileStream</strong> 对象来创建一个新的文件，或打开一个已有的文件。创建 <strong>FileStream</strong> 对象的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileStream &lt;object_name&gt; = new FileStream( &lt;file_name&gt;,</span><br><span class="line">&lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);</span><br></pre></td></tr></table></figure><p>例如，创建一个 FileStream 对象 <strong>F</strong> 来读取名为 <strong>sample.txt</strong> 的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream F = new FileStream(&quot;sample.txt&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>FileMode</td><td><strong>FileMode</strong> 枚举定义了各种打开文件的方法。FileMode 枚举的成员有：<strong>Append</strong>：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。<strong>Create</strong>：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。<strong>CreateNew</strong>：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。<strong>Open</strong>：打开一个已有的文件。如果文件不存在，则抛出异常。<strong>OpenOrCreate</strong>：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。<strong>Truncate</strong>：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。</td></tr><tr><td>FileAccess</td><td><strong>FileAccess</strong> 枚举的成员有：<strong>Read</strong>、<strong>ReadWrite</strong> 和 <strong>Write</strong>。</td></tr><tr><td>FileShare</td><td><strong>FileShare</strong> 枚举的成员有：<strong>Inheritable</strong>：允许文件句柄可由子进程继承。Win32 不直接支持此功能。<strong>None</strong>：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。<strong>Read</strong>：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>ReadWrite</strong>：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>Write</strong>：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>Delete</strong>：允许随后删除文件。</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的程序演示了 <strong>FileStream</strong> 类的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace FileIOApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            FileStream F = new FileStream(&quot;test.dat&quot;, </span><br><span class="line">            FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">            for (int i = 1; i &lt;= 20; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                F.WriteByte((byte)i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            F.Position = 0;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt;= 20; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(F.ReadByte() + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            F.Close();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1</span><br></pre></td></tr></table></figure><p>C# 教程</p><p>C# 教程</p><p>C# 简介</p><p>C# 环境</p><p>C# 程序结构</p><p>C# 基本语法</p><p>C# 数据类型</p><p>C# 类型转换</p><p>C# 变量</p><p>C# 常量</p><p>C# 运算符</p><p>C# 判断</p><p>C# 循环</p><p>C# 封装</p><p>C# 方法</p><p>C# 可空类型</p><p>C# 数组（Array）</p><p>C# 字符串（String）</p><p>C# 结构体（Struct）</p><p>C# 枚举（Enum）</p><p>C# 类（Class）</p><p>C# 继承</p><p>C# 多态性</p><p>C# 运算符重载</p><p>C# 接口（Interface）</p><p>C# 命名空间（Namespace）</p><p>C# 预处理器指令</p><p>C# 正则表达式</p><p>C# 异常处理</p><p>C# 文件的输入与输出</p><h2 id="C-高级教程"><a href="#C-高级教程" class="headerlink" title="C# 高级教程"></a>C# 高级教程</h2><p>C# 特性（Attribute）</p><p>C# 反射（Reflection）</p><p>C# 属性（Property）</p><p>C# 索引器（Indexer）</p><p>C# 委托（Delegate）</p><p>C# 事件（Event）</p><p>C# 集合（Collection）</p><p>C# 泛型（Generic）</p><p>C# 匿名方法</p><p>C# 不安全代码</p><p>C# 多线程</p><p> <a href="http://www.runoob.com/csharp/csharp-exception-handling.html" target="_blank" rel="noopener">C# 异常处理</a></p><p><a href="http://www.runoob.com/csharp/csharp-attribute.html" target="_blank" rel="noopener">C# 特性（Attribute）</a> </p><h1 id="C-文件的输入与输出-1"><a href="#C-文件的输入与输出-1" class="headerlink" title="C# 文件的输入与输出"></a>C# 文件的输入与输出</h1><p>一个 <strong>文件</strong> 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 <strong>流</strong>。</p><p>从根本上说，流是通过通信路径传递的字节序列。有两个主要的流：<strong>输入流</strong> 和 <strong>输出流</strong>。<strong>输入流</strong>用于从文件读取数据（写操作），<strong>输出流</strong>用于向文件写入数据（读操作）。</p><h2 id="C-I-O-类-1"><a href="#C-I-O-类-1" class="headerlink" title="C# I/O 类"></a>C# I/O 类</h2><p>System.IO 命名空间有各种不同的类，用于执行各种文件操作，如创建和删除文件、读取或写入文件，关闭文件等。</p><p>下表列出了一些 System.IO 命名空间中常用的非抽象类：</p><table><thead><tr><th>I/O 类</th><th>描述</th></tr></thead><tbody><tr><td>BinaryReader</td><td>从二进制流读取原始数据。</td></tr><tr><td>BinaryWriter</td><td>以二进制格式写入原始数据。</td></tr><tr><td>BufferedStream</td><td>字节流的临时存储。</td></tr><tr><td>Directory</td><td>有助于操作目录结构。</td></tr><tr><td>DirectoryInfo</td><td>用于对目录执行操作。</td></tr><tr><td>DriveInfo</td><td>提供驱动器的信息。</td></tr><tr><td>File</td><td>有助于处理文件。</td></tr><tr><td>FileInfo</td><td>用于对文件执行操作。</td></tr><tr><td>FileStream</td><td>用于文件中任何位置的读写。</td></tr><tr><td>MemoryStream</td><td>用于随机访问存储在内存中的数据流。</td></tr><tr><td>Path</td><td>对路径信息执行操作。</td></tr><tr><td>StreamReader</td><td>用于从字节流中读取字符。</td></tr><tr><td>StreamWriter</td><td>用于向一个流中写入字符。</td></tr><tr><td>StringReader</td><td>用于读取字符串缓冲区。</td></tr><tr><td>StringWriter</td><td>用于写入字符串缓冲区。</td></tr></tbody></table><h2 id="FileStream-类"><a href="#FileStream-类" class="headerlink" title="FileStream 类"></a>FileStream 类</h2><p>System.IO 命名空间中的 <strong>FileStream</strong> 类有助于文件的读写与关闭。该类派生自抽象类 Stream。</p><p>您需要创建一个 <strong>FileStream</strong> 对象来创建一个新的文件，或打开一个已有的文件。创建 <strong>FileStream</strong> 对象的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileStream &lt;object_name&gt; = new FileStream( &lt;file_name&gt;,</span><br><span class="line">&lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);</span><br></pre></td></tr></table></figure><p>例如，创建一个 FileStream 对象 <strong>F</strong> 来读取名为 <strong>sample.txt</strong> 的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream F = new FileStream(&quot;sample.txt&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>FileMode</td><td><strong>FileMode</strong> 枚举定义了各种打开文件的方法。FileMode 枚举的成员有：<strong>Append</strong>：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。<strong>Create</strong>：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。<strong>CreateNew</strong>：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。<strong>Open</strong>：打开一个已有的文件。如果文件不存在，则抛出异常。<strong>OpenOrCreate</strong>：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。<strong>Truncate</strong>：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。</td></tr><tr><td>FileAccess</td><td><strong>FileAccess</strong> 枚举的成员有：<strong>Read</strong>、<strong>ReadWrite</strong> 和 <strong>Write</strong>。</td></tr><tr><td>FileShare</td><td><strong>FileShare</strong> 枚举的成员有：<strong>Inheritable</strong>：允许文件句柄可由子进程继承。Win32 不直接支持此功能。<strong>None</strong>：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。<strong>Read</strong>：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>ReadWrite</strong>：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>Write</strong>：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。<strong>Delete</strong>：允许随后删除文件。</td></tr></tbody></table><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>下面的程序演示了 <strong>FileStream</strong> 类的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace FileIOApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            FileStream F = new FileStream(&quot;test.dat&quot;, </span><br><span class="line">            FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">            for (int i = 1; i &lt;= 20; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                F.WriteByte((byte)i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            F.Position = 0;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt;= 20; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(F.ReadByte() + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            F.Close();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1</span><br></pre></td></tr></table></figure><h2 id="C-高级文件操作"><a href="#C-高级文件操作" class="headerlink" title="C# 高级文件操作"></a>C# 高级文件操作</h2><p>上面的实例演示了 C# 中简单的文件操作。但是，要充分利用 C# System.IO 类的强大功能，您需要知道这些类常用的属性和方法。</p><p>在下面的章节中，我们将讨论这些类和它们执行的操作。请单击链接详细了解各个部分的知识：</p><table><thead><tr><th>主题</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-text-files.html" target="_blank" rel="noopener">文本文件的读写</a></td><td>它涉及到文本文件的读写。<strong>StreamReader</strong> 和 <strong>StreamWriter</strong> 类有助于完成文本文件的读写。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-binary-files.html" target="_blank" rel="noopener">二进制文件的读写</a></td><td>它涉及到二进制文件的读写。<strong>BinaryReader</strong> 和 <strong>BinaryWriter</strong> 类有助于完成二进制文件的读写。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-windows-file-system.html" target="_blank" rel="noopener">Windows 文件系统的操作</a></td><td>它让 C# 程序员能够浏览并定位 Windows 文件和目录。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-文件的输入与输出&quot;&gt;&lt;a href=&quot;#C-文件的输入与输出&quot; class=&quot;headerlink&quot; title=&quot;C# 文件的输入与输出&quot;&gt;&lt;/a&gt;C# 文件的输入与输出&lt;/h1&gt;&lt;p&gt;一个 &lt;strong&gt;文件&lt;/strong&gt; 是一个存储在磁盘中带有指定
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(16)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-16/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-16/</id>
    <published>2018-06-26T07:46:20.000Z</published>
    <updated>2018-06-26T08:02:47.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C# 异常处理"></a>C# 异常处理</h1><p>异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。</p><p>异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong>和 <strong>throw</strong>。</p><ul><li><strong>try</strong>：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。</li><li><strong>catch</strong>：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。</li><li><strong>finally</strong>：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。</li><li><strong>throw</strong>：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>假设一个块将出现异常，一个方法使用 try 和 catch 关键字捕获异常。try/catch 块内的代码为受保护的代码，使用 try/catch 语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   // 引起异常的语句</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   // 错误处理代码</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   // 错误处理代码</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   // 错误处理代码</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">   // 要执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以列出多个 catch 语句捕获不同类型的异常，以防 try 块在不同的情况下生成多个异常。 </p><h2 id="C-中的异常类"><a href="#C-中的异常类" class="headerlink" title="C# 中的异常类"></a>C# 中的异常类</h2><p>C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 <strong>System.Exception</strong> 类。<strong>System.ApplicationException</strong> 和 <strong>System.SystemException</strong> 类是派生于 System.Exception 类的异常类。</p><p><strong>System.ApplicationException</strong> 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。</p><p><strong>System.SystemException</strong> 类是所有预定义的系统异常的基类。</p><p>下表列出了一些派生自 Sytem.SystemException 类的预定义的异常类：</p><table><thead><tr><th style="text-align:center">异常类</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">System.IO.IOException</td><td style="text-align:center">处理 I/O 错误。</td></tr><tr><td style="text-align:center">System.IndexOutOfRangeException</td><td style="text-align:center">处理当方法指向超出范围的数组索引时生成的错误。</td></tr><tr><td style="text-align:center">System.ArrayTypeMismatchException</td><td style="text-align:center">处理当数组类型不匹配时生成的错误。</td></tr><tr><td style="text-align:center">System.NullReferenceException</td><td style="text-align:center">处理当依从一个空对象时生成的错误。</td></tr><tr><td style="text-align:center">System.DivideByZeroException</td><td style="text-align:center">处理当除以零时生成的错误。</td></tr><tr><td style="text-align:center">System.InvalidCastException</td><td style="text-align:center">处理在类型转换期间生成的错误。</td></tr><tr><td style="text-align:center">System.OutOfMemoryException</td><td style="text-align:center">处理空闲内存不足生成的错误。</td></tr><tr><td style="text-align:center">System.StackOverflowException</td><td style="text-align:center">处理栈溢出生成的错误。</td></tr></tbody></table><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。</p><p>这些错误处理块是使用 <strong>try</strong>、<strong>catch</strong> 和 <strong>finally</strong> 关键字实现的。下面是一个当除以零时抛出异常的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ErrorHandlingApplication</span><br><span class="line">&#123;</span><br><span class="line">    class DivNumbers</span><br><span class="line">    &#123;</span><br><span class="line">        int result;</span><br><span class="line">        DivNumbers()</span><br><span class="line">        &#123;</span><br><span class="line">            result = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        public void division(int num1, int num2)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (DivideByZeroException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Exception caught: &#123;0&#125;&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Result: &#123;0&#125;&quot;, result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            DivNumbers d = new DivNumbers();</span><br><span class="line">            d.division(25, 0);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception caught: System.DivideByZeroException: Attempted to divide by zero. </span><br><span class="line">at ...</span><br><span class="line">Result: 0</span><br></pre></td></tr></table></figure><h2 id="创建用户自定义异常"><a href="#创建用户自定义异常" class="headerlink" title="创建用户自定义异常"></a>创建用户自定义异常</h2><p>您也可以定义自己的异常。用户自定义的异常类是派生自 <strong>ApplicationException</strong> 类。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace UserDefinedException</span><br><span class="line">&#123;</span><br><span class="line">   class TestTemperature</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Temperature temp = new Temperature();</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            temp.showTemp();</span><br><span class="line">         &#125;</span><br><span class="line">         catch(TempIsZeroException e)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(&quot;TempIsZeroException: &#123;0&#125;&quot;, e.Message);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TempIsZeroException: ApplicationException</span><br><span class="line">&#123;</span><br><span class="line">   public TempIsZeroException(string message): base(message)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Temperature</span><br><span class="line">&#123;</span><br><span class="line">   int temperature = 0;</span><br><span class="line">   public void showTemp()</span><br><span class="line">   &#123;</span><br><span class="line">      if(temperature == 0)</span><br><span class="line">      &#123;</span><br><span class="line">         throw (new TempIsZeroException(&quot;Zero Temperature found&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Temperature: &#123;0&#125;&quot;, temperature);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TempIsZeroException: Zero Temperature found</span><br></pre></td></tr></table></figure><h2 id="抛出对象"><a href="#抛出对象" class="headerlink" title="抛出对象"></a>抛出对象</h2><p>如果异常是直接或间接派生自 <strong>System.Exception</strong> 类，您可以抛出一个对象。您可以在 catch 块中使用 throw 语句来抛出当前的对象，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   Throw e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-异常处理&quot;&gt;&lt;a href=&quot;#C-异常处理&quot; class=&quot;headerlink&quot; title=&quot;C# 异常处理&quot;&gt;&lt;/a&gt;C# 异常处理&lt;/h1&gt;&lt;p&gt;异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(15)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-15/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-15/</id>
    <published>2018-06-26T07:20:09.000Z</published>
    <updated>2018-06-26T07:45:57.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-正则表达式"><a href="#C-正则表达式" class="headerlink" title="C# 正则表达式"></a>C# 正则表达式</h1><p><strong>正则表达式</strong> 是一种匹配输入文本的模式。.Net 框架提供了允许这种匹配的正则表达式引擎。模式由一个或多个字符、运算符和结构组成。 </p><h2 id="定义正则表达式"><a href="#定义正则表达式" class="headerlink" title="定义正则表达式"></a>定义正则表达式</h2><p>下面列出了用于定义正则表达式的各种类别的字符、运算符和结构。</p><ul><li>字符转义</li><li>字符类</li><li>定位点</li><li>分组构造</li><li>限定符</li><li>反向引用构造</li><li>备用构造</li><li>替换</li><li>杂项构造</li></ul><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>正则表达式中的反斜杠字符（\）指示其后跟的字符是特殊字符，或应按原义解释该字符。</p><p>下表列出了转义字符：</p><table><thead><tr><th>转义字符</th><th>描述</th><th>模式</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td><strong>\a</strong></td><td>与报警 (bell) 符 \u0007 匹配。</td><td>\a</td><td style="text-align:center">“Warning!” + ‘\u0007’ 中的 “\u0007”</td></tr><tr><td><strong>\b</strong></td><td>在字符类中，与退格键 \u0008 匹配。</td><td>[\b]{3,}</td><td style="text-align:center">“\b\b\b\b” 中的 “\b\b\b\b”</td></tr><tr><td><strong>\t</strong></td><td>与制表符 \u0009 匹配。</td><td>(\w+)\t</td><td style="text-align:center">“Name\tAddr\t” 中的 “Name\t” 和 “Addr\t”</td></tr><tr><td><strong>\r</strong></td><td>与回车符 \u000D 匹配。（\r 与换行符 \n 不是等效的。）</td><td>\r\n(\w+)</td><td style="text-align:center">“\r\Hello\nWorld.” 中的 “\r\nHello”</td></tr><tr><td><strong>\v</strong></td><td>与垂直制表符 \u000B 匹配。</td><td>[\v]{2,}</td><td style="text-align:center">“\v\v\v” 中的 “\v\v\v”</td></tr><tr><td><strong>\f</strong></td><td>与换页符 \u000C 匹配。</td><td>[\f]{2,}</td><td style="text-align:center">“\f\f\f” 中的 “\f\f\f”</td></tr><tr><td><strong>\n</strong></td><td>与换行符 \u000A 匹配。</td><td>\r\n(\w+)</td><td style="text-align:center">“\r\Hello\nWorld.” 中的 “\r\nHello”</td></tr><tr><td><strong>\e</strong></td><td>与转义符 \u001B 匹配。</td><td>\e</td><td style="text-align:center">“\x001B” 中的 “\x001B”</td></tr><tr><td><strong>\ nnn</strong></td><td>使用八进制表示形式指定一个字符（nnn 由二到三位数字组成）。</td><td>\w\040\w</td><td style="text-align:center">“a bc d” 中的 “a b” 和 “c d”</td></tr><tr><td><strong>\x nn</strong></td><td>使用十六进制表示形式指定字符（nn 恰好由两位数字组成）。</td><td>\w\x20\w</td><td style="text-align:center">“a bc d” 中的 “a b” 和 “c d”</td></tr><tr><td><strong>\c X \c x</strong></td><td>匹配 X 或 x 指定的 ASCII 控件字符，其中 X 或 x 是控件字符的字母。</td><td>\cC</td><td style="text-align:center">“\x0003” 中的 “\x0003” (Ctrl-C)</td></tr><tr><td><strong>\u nnnn</strong></td><td>使用十六进制表示形式匹配一个 Unicode 字符（由 nnnn 表示的四位数）。</td><td>\w\u0020\w</td><td style="text-align:center">“a bc d” 中的 “a b” 和 “c d”</td></tr><tr><td><strong>\</strong></td><td>在后面带有不识别的转义字符时，与该字符匹配。</td><td>\d+[+-x*]\d+\d+[+-x*\d+</td><td style="text-align:center">“(2+2) <em> 3</em>9” 中的 “2+2” 和 “3*9”</td></tr></tbody></table><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类与一组字符中的任何一个字符匹配。</p><p>下表列出了字符类：</p><table><thead><tr><th style="text-align:center">字符类</th><th style="text-align:center">描述</th><th style="text-align:center">模式</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[character_group]</strong></td><td style="text-align:center">匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。</td><td style="text-align:center">[mn]</td><td style="text-align:center">“mat” 中的 “m”，”moon” 中的 “m” 和 “n”</td></tr><tr><td style="text-align:center"><strong>[^character_group]</strong></td><td style="text-align:center">非：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。</td><td style="text-align:center">[^aei]</td><td style="text-align:center">“avail” 中的 “v” 和 “l”</td></tr><tr><td style="text-align:center"><strong>[ first - last ]</strong></td><td style="text-align:center">字符范围：与从 first 到 last 的范围中的任何单个字符匹配。</td><td style="text-align:center">[b-d]</td><td style="text-align:center">[b-d]irds 可以匹配 Birds、 Cirds、 Dirds</td></tr><tr><td style="text-align:center"><strong>.</strong></td><td style="text-align:center">通配符：与除 \n 之外的任何单个字符匹配。  若要匹配原意句点字符（. 或 \u002E），您必须在该字符前面加上转义符 (.)。</td><td style="text-align:center">a.e</td><td style="text-align:center">“have” 中的 “ave”， “mate” 中的 “ate”</td></tr><tr><td style="text-align:center"><strong>\p{ name }</strong></td><td style="text-align:center">与 <em>name</em> 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</td><td style="text-align:center">\p{Lu}</td><td style="text-align:center">“City Lights” 中的 “C” 和 “L”</td></tr><tr><td style="text-align:center"><strong>\P{ name }</strong></td><td style="text-align:center">与不在 <em>name</em> 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</td><td style="text-align:center">\P{Lu}</td><td style="text-align:center">“City” 中的 “i”、 “t” 和 “y”</td></tr><tr><td style="text-align:center"><strong>\w</strong></td><td style="text-align:center">与任何单词字符匹配。</td><td style="text-align:center">\w</td><td style="text-align:center">“Room#1” 中的 “R”、 “o”、 “m” 和 “1”</td></tr><tr><td style="text-align:center"><strong>\W</strong></td><td style="text-align:center">与任何非单词字符匹配。</td><td style="text-align:center">\W</td><td style="text-align:center">“Room#1” 中的 “#”</td></tr><tr><td style="text-align:center"><strong>\s</strong></td><td style="text-align:center">与任何空白字符匹配。</td><td style="text-align:center">\w\s</td><td style="text-align:center">“ID A1.3” 中的 “D “</td></tr><tr><td style="text-align:center"><strong>\S</strong></td><td style="text-align:center">与任何非空白字符匹配。</td><td style="text-align:center">\s\S</td><td style="text-align:center">“int __ctr” 中的 “ _”</td></tr><tr><td style="text-align:center"><strong>\d</strong></td><td style="text-align:center">与任何十进制数字匹配。</td><td style="text-align:center">\d</td><td style="text-align:center">“4 = IV” 中的 “4”</td></tr><tr><td style="text-align:center"><strong>\D</strong></td><td style="text-align:center">匹配不是十进制数的任意字符。</td><td style="text-align:center">\D</td><td style="text-align:center">“4 = IV” 中的 “ “、 “=”、 “ “、 “I” 和 “V”</td></tr></tbody></table><h3 id="定位点"><a href="#定位点" class="headerlink" title="定位点"></a>定位点</h3><p>定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符。</p><p>下表列出了定位点：</p><table><thead><tr><th>断言</th><th>描述</th><th style="text-align:center">模式</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td><strong>^</strong></td><td>匹配必须从字符串或一行的开头开始。</td><td style="text-align:center">^\d{3}</td><td style="text-align:center">“567-777-“ 中的 “567”</td></tr><tr><td><strong>$</strong></td><td>匹配必须出现在字符串的末尾或出现在行或字符串末尾的 <strong>\n</strong> 之前。</td><td style="text-align:center">-\d{4}$</td><td style="text-align:center">“8-12-2012” 中的 “-2012”</td></tr><tr><td><strong>\A</strong></td><td>匹配必须出现在字符串的开头。</td><td style="text-align:center">\A\w{4}</td><td style="text-align:center">“Code-007-“ 中的 “Code”</td></tr><tr><td><strong>\Z</strong></td><td>匹配必须出现在字符串的末尾或出现在字符串末尾的 <strong>\n</strong> 之前。</td><td style="text-align:center">-\d{3}\Z</td><td style="text-align:center">“Bond-901-007” 中的 “-007”</td></tr><tr><td><strong>\z</strong></td><td>匹配必须出现在字符串的末尾。</td><td style="text-align:center">-\d{3}\z</td><td style="text-align:center">“-901-333” 中的 “-333”</td></tr><tr><td><strong>\G</strong></td><td>匹配必须出现在上一个匹配结束的地方。</td><td style="text-align:center">\G(\d)</td><td style="text-align:center">“(1)(3)(5)<a href="9">7</a>“ 中的 “(1)”、 “(3)” 和 “(5)”</td></tr><tr><td><strong>\b</strong></td><td>匹配一个单词边界，也就是指单词和空格间的位置。</td><td style="text-align:center">er\b</td><td style="text-align:center">匹配”never”中的”er”，但不能匹配”verb”中的”er”。</td></tr><tr><td><strong>\B</strong></td><td>匹配非单词边界。</td><td style="text-align:center">er\B</td><td style="text-align:center">匹配”verb”中的”er”，但不能匹配”never”中的”er”。</td></tr></tbody></table><h3 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a>分组构造</h3><p>分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。</p><p>下表列出了分组构造：</p><table><thead><tr><th style="text-align:center">分组构造</th><th style="text-align:center">描述</th><th style="text-align:center">模式</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td style="text-align:center"><strong>( subexpression )</strong></td><td style="text-align:center">捕获匹配的子表达式并将其分配到一个从零开始的序号中。</td><td style="text-align:center">(\w)\1</td><td style="text-align:center">“deep” 中的 “ee”</td></tr><tr><td style="text-align:center"><strong>(?&lt; name &gt;subexpression)</strong></td><td style="text-align:center">将匹配的子表达式捕获到一个命名组中。</td><td style="text-align:center">(?&lt; double&gt;\w)\k&lt; double&gt;</td><td style="text-align:center">“deep” 中的 “ee”</td></tr><tr><td style="text-align:center"><strong>(?&lt; name1 -name2 &gt;subexpression)</strong></td><td style="text-align:center">定义平衡组定义。</td><td style="text-align:center">(((?’Open’()[^()]<em>)+((?’Close-Open’))[^()]</em>)+)*(?(Open)(?!))$</td><td style="text-align:center">“3+2^((1-3)<em>(3-1))” 中的 “((1-3)</em>(3-1))”</td></tr><tr><td style="text-align:center"><strong>(?: subexpression)</strong></td><td style="text-align:center">定义非捕获组。</td><td style="text-align:center">Write(?:Line)?</td><td style="text-align:center">“Console.WriteLine()” 中的 “WriteLine”</td></tr><tr><td style="text-align:center"><strong>(?imnsx-imnsx:subexpression)</strong></td><td style="text-align:center">应用或禁用 <em>subexpression</em>中指定的选项。</td><td style="text-align:center">A\d{2}(?i:\w+)\b</td><td style="text-align:center">“A12xl A12XL a12xl” 中的 “A12xl” 和 “A12XL”</td></tr><tr><td style="text-align:center"><strong>(?= subexpression)</strong></td><td style="text-align:center">零宽度正预测先行断言。</td><td style="text-align:center">\w+(?=.)</td><td style="text-align:center">“He is. The dog ran. The sun is out.” 中的 “is”、 “ran” 和 “out”</td></tr><tr><td style="text-align:center"><strong>(?! subexpression)</strong></td><td style="text-align:center">零宽度负预测先行断言。</td><td style="text-align:center">\b(?!un)\w+\b</td><td style="text-align:center">“unsure sure unity used” 中的 “sure” 和 “used”</td></tr><tr><td style="text-align:center"><strong>(?&lt;=subexpression)</strong></td><td style="text-align:center">零宽度正回顾后发断言。</td><td style="text-align:center">(?&lt;=19)\d{2}\b</td><td style="text-align:center">“1851 1999 1950 1905 2003” 中的 “99”、”50”和 “05”</td></tr><tr><td style="text-align:center"><strong>(?&lt;! subexpression)</strong></td><td style="text-align:center">零宽度负回顾后发断言。</td><td style="text-align:center">(?</td><td style="text-align:center">“Hi woman Hi man” 中的 “man”</td></tr><tr><td style="text-align:center"><strong>(?&gt; subexpression)</strong></td><td style="text-align:center">非回溯（也称为”贪婪”）子表达式。</td><td style="text-align:center"><a href="?&gt;A+B+">13579</a></td><td style="text-align:center">“1ABB 3ABBC 5AB 5AC” 中的 “1ABB”、 “3ABB” 和 “5AB”</td></tr></tbody></table> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">public class Example</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line">      string input = &quot;1851 1999 1950 1905 2003&quot;;</span><br><span class="line">      string pattern = @&quot;(?&lt;=19)\d&#123;2&#125;\b&quot;;</span><br><span class="line"></span><br><span class="line">      foreach (Match match in Regex.Matches(input, pattern))</span><br><span class="line">         Console.WriteLine(match.Value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 限定符包括下表中列出的语言元素。</p><p>下表列出了限定符：</p><table><thead><tr><th>限定符</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td><strong>*</strong></td><td>匹配上一个元素零次或多次。</td><td>\d*.\d</td><td>“.0”、 “19.9”、 “219.9”</td></tr><tr><td><strong>+</strong></td><td>匹配上一个元素一次或多次。</td><td>“be+”</td><td>“been” 中的 “bee”， “bent” 中的 “be”</td></tr><tr><td><strong>?</strong></td><td>匹配上一个元素零次或一次。</td><td>“rai?n”</td><td>“ran”、 “rain”</td></tr><tr><td><strong>{ n }</strong></td><td>匹配上一个元素恰好 n 次。</td><td>“,\d{3}”</td><td>“1,043.6” 中的 “,043”， “9,876,543,210” 中的 “,876”、 “,543” 和 “,210”</td></tr><tr><td><strong>{ n ,}</strong></td><td>匹配上一个元素至少 n 次。</td><td>“\d{2,}”</td><td>“166”、 “29”、 “1930”</td></tr><tr><td><strong>{ n , m }</strong></td><td>匹配上一个元素至少 n 次，但不多于 m 次。</td><td>“\d{3,5}”</td><td>“166”， “17668”， “193024” 中的 “19302”</td></tr><tr><td><strong>*?</strong></td><td>匹配上一个元素零次或多次，但次数尽可能少。</td><td>\d*?.\d</td><td>“.0”、 “19.9”、 “219.9”</td></tr><tr><td><strong>+?</strong></td><td>匹配上一个元素一次或多次，但次数尽可能少。</td><td>“be+?”</td><td>“been” 中的 “be”， “bent” 中的 “be”</td></tr><tr><td><strong>??</strong></td><td>匹配上一个元素零次或一次，但次数尽可能少。</td><td>“rai??n”</td><td>“ran”、 “rain”</td></tr><tr><td><strong>{ n }?</strong></td><td>匹配前导元素恰好 n 次。</td><td>“,\d{3}?”</td><td>“1,043.6” 中的 “,043”， “9,876,543,210” 中的 “,876”、 “,543” 和 “,210”</td></tr><tr><td><strong>{ n ,}?</strong></td><td>匹配上一个元素至少 n 次，但次数尽可能少。</td><td>“\d{2,}?”</td><td>“166”、 “29” 和 “1930”</td></tr><tr><td><strong>{ n , m }?</strong></td><td>匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。</td><td>“\d{3,5}?”</td><td>“166”， “17668”， “193024” 中的 “193” 和 “024”</td></tr></tbody></table><h3 id="反向引用构造"><a href="#反向引用构造" class="headerlink" title="反向引用构造"></a>反向引用构造</h3><p>反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。</p><p>下表列出了反向引用构造：</p><table><thead><tr><th>反向引用构造</th><th>描述</th><th>模式</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td><strong>\ number</strong></td><td>反向引用。 匹配编号子表达式的值。</td><td>(\w)\1</td><td style="text-align:center">“seek” 中的 “ee”</td></tr><tr><td><strong>\k&lt; name &gt;</strong></td><td>命名反向引用。 匹配命名表达式的值。</td><td>(?&lt; char&gt;\w)\k&lt; char&gt;</td><td style="text-align:center">“seek” 中的 “ee”</td></tr></tbody></table><h3 id="杂项构造"><a href="#杂项构造" class="headerlink" title="杂项构造"></a>杂项构造</h3><p>下表列出了各种杂项构造：</p><table><thead><tr><th>构造</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><strong>(?imnsx-imnsx)</strong></td><td>在模式中间对诸如不区分大小写这样的选项进行设置或禁用。</td><td>\bA(?i)b\w+\b 匹配 “ABA Able Act” 中的 “ABA” 和 “Able”</td></tr><tr><td><strong>(?#注释)</strong></td><td>内联注释。该注释在第一个右括号处终止。</td><td>\bA(?#匹配以A开头的单词)\w+\b</td></tr><tr><td><strong>#</strong> [行尾]</td><td>该注释以非转义的 # 开头，并继续到行的结尾。</td><td>(?x)\bA\w+\b#匹配以 A 开头的单词</td></tr></tbody></table><h2 id="Regex-类"><a href="#Regex-类" class="headerlink" title="Regex 类"></a>Regex 类</h2><p>Regex 类用于表示一个正则表达式。</p><p>下表列出了 Regex 类中一些常用的方法：</p><table><thead><tr><th>序号</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public bool IsMatch( string input )</strong>  指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项。</td></tr><tr><td>2</td><td><strong>public bool IsMatch( string input, int startat )</strong>  指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的开始位置开始。</td></tr><tr><td>3</td><td><strong>public static bool IsMatch( string input, string pattern )</strong>  指示指定的正则表达式是否在指定的输入字符串中找到匹配项。</td></tr><tr><td>4</td><td><strong>public MatchCollection Matches( string input )</strong>  在指定的输入字符串中搜索正则表达式的所有匹配项。</td></tr><tr><td>5</td><td><strong>public string Replace( string input, string replacement )</strong>  在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串。</td></tr><tr><td>6</td><td><strong>public string[] Split( string input )</strong>  把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割。</td></tr></tbody></table><p>如需了解 Regex 类的完整的属性列表，请参阅微软的 C# 文档。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h2><p>下面的实例匹配了以 ‘S’ 开头的单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">namespace RegExApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      private static void showMatch(string text, string expr)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;The Expression: &quot; + expr);</span><br><span class="line">         MatchCollection mc = Regex.Matches(text, expr);</span><br><span class="line">         foreach (Match m in mc)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(m);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str = &quot;A Thousand Splendid Suns&quot;;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;Matching words that start with &apos;S&apos;: &quot;);</span><br><span class="line">         showMatch(str, @&quot;\bS\S*&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matching words that start with &apos;S&apos;:</span><br><span class="line">The Expression: \bS\S*</span><br><span class="line">Splendid</span><br><span class="line">Suns</span><br></pre></td></tr></table></figure><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h2><p>下面的实例匹配了以 ‘m’ 开头以 ‘e’ 结尾的单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">namespace RegExApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      private static void showMatch(string text, string expr)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;The Expression: &quot; + expr);</span><br><span class="line">         MatchCollection mc = Regex.Matches(text, expr);</span><br><span class="line">         foreach (Match m in mc)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(m);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str = &quot;make maze and manage to measure it&quot;;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;Matching words start with &apos;m&apos; and ends with &apos;e&apos;:&quot;);</span><br><span class="line">         showMatch(str, @&quot;\bm\S*e\b&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;using System;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">namespace RegExApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      private static void showMatch(string text, string expr)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;The Expression: &quot; + expr);</span><br><span class="line">         MatchCollection mc = Regex.Matches(text, expr);</span><br><span class="line">         foreach (Match m in mc)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(m);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str = &quot;make maze and manage to measure it&quot;;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;Matching words start with &apos;m&apos; and ends with &apos;e&apos;:&quot;);</span><br><span class="line">         showMatch(str, @&quot;\bm\S*e\b&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matching words start with &apos;m&apos; and ends with &apos;e&apos;:</span><br><span class="line">The Expression: \bm\S*e\b</span><br><span class="line">make</span><br><span class="line">maze</span><br><span class="line">manage</span><br><span class="line">measure</span><br></pre></td></tr></table></figure><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例 3"></a>实例 3</h2><p>下面的实例替换掉多余的空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">namespace RegExApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string input = &quot;Hello   World   &quot;;</span><br><span class="line">         string pattern = &quot;\\s+&quot;;</span><br><span class="line">         string replacement = &quot; &quot;;</span><br><span class="line">         Regex rgx = new Regex(pattern);</span><br><span class="line">         string result = rgx.Replace(input, replacement);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;Original String: &#123;0&#125;&quot;, input);</span><br><span class="line">         Console.WriteLine(&quot;Replacement String: &#123;0&#125;&quot;, result);    </span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original String: Hello   World   </span><br><span class="line">Replacement String: Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-正则表达式&quot;&gt;&lt;a href=&quot;#C-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;C# 正则表达式&quot;&gt;&lt;/a&gt;C# 正则表达式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt; 是一种匹配输入文本的模式。.Net 框架提供了允许
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(14)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-14/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-14/</id>
    <published>2018-06-26T06:38:11.000Z</published>
    <updated>2018-06-26T07:17:39.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-命名空间（Namespace）"><a href="#C-命名空间（Namespace）" class="headerlink" title="C# 命名空间（Namespace）"></a>C# 命名空间（Namespace）</h1><p><strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 </p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>命名空间的定义是以关键字 <strong>namespace</strong> 开始，后跟命名空间的名称，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name</span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace_name.item_name;</span><br></pre></td></tr></table></figure><p>下面的程序演示了命名空间的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">    class namespace_c1</span><br><span class="line">    &#123;</span><br><span class="line">        public void func()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace second_space</span><br><span class="line">&#123;</span><br><span class="line">    class namespace_c2</span><br><span class="line">    &#123;</span><br><span class="line">        public void func()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Inside second_space&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        first_space.namespace_c1 fc = new first_space.namespace_c1();</span><br><span class="line">        second_space.namespace_c2 sc = new second_space.namespace_c2();</span><br><span class="line">        fc.func();</span><br><span class="line">        sc.func();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h2 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h2><p><strong>using</strong> 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 <strong>System</strong> 命名空间，其中定义了类 Console。我们可以只写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello there&quot;);</span><br></pre></td></tr></table></figure><p>我们可以写完全限定名称，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Console.WriteLine(&quot;Hello there&quot;);</span><br></pre></td></tr></table></figure><p>您也可以使用 <strong>using</strong> 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。下面的代码演示了命名空间的应用。</p><p>让我们使用 using 指定重写上面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using first_space;</span><br><span class="line">using second_space;</span><br><span class="line"></span><br><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">   class abc</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace second_space</span><br><span class="line">&#123;</span><br><span class="line">   class efg</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside second_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;   </span><br><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">   static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      abc fc = new abc();</span><br><span class="line">      efg sc = new efg();</span><br><span class="line">      fc.func();</span><br><span class="line">      sc.func();</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h2 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h2><p>命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 </span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 </span><br><span class="line">   &#123;</span><br><span class="line">     // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用点（.）运算符访问嵌套的命名空间的成员，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using SomeNameSpace;</span><br><span class="line">using SomeNameSpace.Nested;</span><br><span class="line"></span><br><span class="line">namespace SomeNameSpace</span><br><span class="line">&#123;</span><br><span class="line">    public class MyClass </span><br><span class="line">    &#123;</span><br><span class="line">        static void Main() </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;In SomeNameSpace&quot;);</span><br><span class="line">            Nested.NestedNameSpaceClass.SayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内嵌命名空间</span><br><span class="line">    namespace Nested   </span><br><span class="line">    &#123;</span><br><span class="line">        public class NestedNameSpaceClass </span><br><span class="line">        &#123;</span><br><span class="line">            public static void SayHello() </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;In Nested&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In SomeNameSpace</span><br><span class="line">In Nested</span><br></pre></td></tr></table></figure><h2 id="using的用法："><a href="#using的用法：" class="headerlink" title="using的用法："></a>using的用法：</h2><p><strong>1. using指令：引入命名空间</strong></p><p>这是最常见的用法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Namespace1.SubNameSpace;</span><br></pre></td></tr></table></figure><p><strong>2. using static 指令：指定无需指定类型名称即可访问其静态成员的类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using static System.Math;var = PI; // 直接使用System.Math.PI</span><br></pre></td></tr></table></figure><p><strong>3. 起别名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using Project = PC.MyCompany.Project;</span><br></pre></td></tr></table></figure><p><strong>4. using语句：将实例与代码绑定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using (Font font3 = new Font(&quot;Arial&quot;, 10.0f),</span><br><span class="line">            font4 = new Font(&quot;Arial&quot;, 10.0f))</span><br><span class="line">&#123;</span><br><span class="line">    // Use font3 and font4.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码段结束时，自动调用font3和font4的Dispose方法，释放实例。</p><h1 id="C-预处理器指令"><a href="#C-预处理器指令" class="headerlink" title="C# 预处理器指令"></a>C# 预处理器指令</h1><p>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。</p><p>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。</p><p>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。</p><h2 id="C-预处理器指令列表"><a href="#C-预处理器指令列表" class="headerlink" title="C# 预处理器指令列表"></a>C# 预处理器指令列表</h2><p>下表列出了 C# 中可用的预处理器指令：</p><table><thead><tr><th>预处理器指令</th><th>描述</th></tr></thead><tbody><tr><td>#define</td><td>它用于定义一系列成为符号的字符。</td></tr><tr><td>#undef</td><td>它用于取消定义符号。</td></tr><tr><td>#if</td><td>它用于测试符号是否为真。</td></tr><tr><td>#else</td><td>它用于创建复合条件指令，与 #if 一起使用。</td></tr><tr><td>#elif</td><td>它用于创建复合条件指令。</td></tr><tr><td>#endif</td><td>指定一个条件指令的结束。</td></tr><tr><td>#line</td><td>它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。</td></tr><tr><td>#error</td><td>它允许从代码的指定位置生成一个错误。</td></tr><tr><td>#warning</td><td>它允许从代码的指定位置生成一级警告。</td></tr><tr><td>#region</td><td>它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。</td></tr><tr><td>#endregion</td><td>它标识着 #region 块的结束。</td></tr></tbody></table><h2 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h2><p>#define预处理器指令创建符号常量。</p><p>#define允许您定义一个符号，这样，通过使用符号作为传递给#if指令的表达式，表达式将返回true。它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define symbol</span><br></pre></td></tr></table></figure><p>下面的程序说明了这点： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define PI</span><br><span class="line">using System;</span><br><span class="line">namespace PreprocessorDApp1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            #if (PI)</span><br><span class="line">                Console.WriteLine(&quot;PI is defined&quot;);</span><br><span class="line">            #else</span><br><span class="line">                Console.WriteLine(&quot;PI is not defined&quot;);</span><br><span class="line">            #endif</span><br><span class="line">                Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI is defined</span><br></pre></td></tr></table></figure><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>您可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。</p><p>条件指令的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#if symbol [operator symbol]...</span><br></pre></td></tr></table></figure><p>其中，<em>symbol</em> 是要测试的符号名称。您也可以使用 true 和 false，或在符号前放置否定运算符。</p><p>常见运算符有：</p><ul><li>== (等于)</li><li>!= (不等于)</li><li>&amp;&amp; (与)</li><li>|| (或)</li></ul><p>您也可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 <strong>#if</strong> 指令开始的条件指令，必须显示地以一个 <strong>#endif</strong> 指令终止。</p><p>下面的程序演示了条件指令的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br><span class="line">#define VC_V10</span><br><span class="line">using System;</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      #if (DEBUG &amp;&amp; !VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;DEBUG is defined&quot;);</span><br><span class="line">      #elif (!DEBUG &amp;&amp; VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;VC_V10 is defined&quot;);</span><br><span class="line">      #elif (DEBUG &amp;&amp; VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;DEBUG and VC_V10 are defined&quot;);</span><br><span class="line">      #else</span><br><span class="line">         Console.WriteLine(&quot;DEBUG and VC_V10 are not defined&quot;);</span><br><span class="line">      #endif</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG and VC_V10 are defined</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-命名空间（Namespace）&quot;&gt;&lt;a href=&quot;#C-命名空间（Namespace）&quot; class=&quot;headerlink&quot; title=&quot;C# 命名空间（Namespace）&quot;&gt;&lt;/a&gt;C# 命名空间（Namespace）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(13)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-13/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-13/</id>
    <published>2018-06-26T05:59:45.000Z</published>
    <updated>2018-06-26T06:37:47.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C# 继承"></a>C# 继承</h1><p>继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。</p><p>当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的<strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。</p><p>继承的思想实现了 <strong>属于（IS-A）</strong> 关系。例如，哺乳动物 <strong>属于（IS-A）</strong> 动物，狗 <strong>属于（IS-A）</strong> 哺乳动物，因此狗 <strong>属于（IS-A）</strong> 动物。</p><h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><p>一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。</p><p>C# 中创建派生类的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;acess-specifier&gt; class &lt;base_class&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">class &lt;derived_class&gt; : &lt;base_class&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设，有一个基类 Shape，它的派生类是 Rectangle： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace InheritanceApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      public void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      protected int width;</span><br><span class="line">      protected int height;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 派生类</span><br><span class="line">   class Rectangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public int getArea()</span><br><span class="line">      &#123; </span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle Rect = new Rectangle();</span><br><span class="line"></span><br><span class="line">         Rect.setWidth(5);</span><br><span class="line">         Rect.setHeight(7);</span><br><span class="line"></span><br><span class="line">         // 打印对象的面积</span><br><span class="line">         Console.WriteLine(&quot;总面积： &#123;0&#125;&quot;,  Rect.getArea());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总面积： 35</span><br></pre></td></tr></table></figure><h2 id="基类的初始化"><a href="#基类的初始化" class="headerlink" title="基类的初始化"></a>基类的初始化</h2><p>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。</p><p>下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Rectangle</span><br><span class="line">   &#123;</span><br><span class="line">      // 成员变量</span><br><span class="line">      protected double length;</span><br><span class="line">      protected double width;</span><br><span class="line">      public Rectangle(double l, double w)</span><br><span class="line">      &#123;</span><br><span class="line">         length = l;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public double GetArea()</span><br><span class="line">      &#123;</span><br><span class="line">         return length * width;</span><br><span class="line">      &#125;</span><br><span class="line">      public void Display()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">         Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;//end class Rectangle  </span><br><span class="line">   class Tabletop : Rectangle</span><br><span class="line">   &#123;</span><br><span class="line">      private double cost;</span><br><span class="line">      public Tabletop(double l, double w) : base(l, w)</span><br><span class="line">      &#123; &#125;</span><br><span class="line">      public double GetCost()</span><br><span class="line">      &#123;</span><br><span class="line">         double cost;</span><br><span class="line">         cost = GetArea() * 70;</span><br><span class="line">         return cost;</span><br><span class="line">      &#125;</span><br><span class="line">      public void Display()</span><br><span class="line">      &#123;</span><br><span class="line">         base.Display();</span><br><span class="line">         Console.WriteLine(&quot;成本： &#123;0&#125;&quot;, GetCost());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class ExecuteRectangle</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Tabletop t = new Tabletop(4.5, 7.5);</span><br><span class="line">         t.Display();</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 7.5</span><br><span class="line">面积： 33.75</span><br><span class="line">成本： 2362.5</span><br></pre></td></tr></table></figure><h2 id="C-多重继承"><a href="#C-多重继承" class="headerlink" title="C# 多重继承"></a>C# 多重继承</h2><p>多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。</p><p><strong>C# 不支持多重继承</strong>。但是，您可以使用接口来实现多重继承。下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace InheritanceApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      public void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      protected int width;</span><br><span class="line">      protected int height;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 基类 PaintCost</span><br><span class="line">   public interface PaintCost </span><br><span class="line">   &#123;</span><br><span class="line">      int getCost(int area);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   // 派生类</span><br><span class="line">   class Rectangle : Shape, PaintCost</span><br><span class="line">   &#123;</span><br><span class="line">      public int getArea()</span><br><span class="line">      &#123;</span><br><span class="line">         return (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">      public int getCost(int area)</span><br><span class="line">      &#123;</span><br><span class="line">         return area * 70;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle Rect = new Rectangle();</span><br><span class="line">         int area;</span><br><span class="line">         Rect.setWidth(5);</span><br><span class="line">         Rect.setHeight(7);</span><br><span class="line">         area = Rect.getArea();</span><br><span class="line">         // 打印对象的面积</span><br><span class="line">         Console.WriteLine(&quot;总面积： &#123;0&#125;&quot;,  Rect.getArea());</span><br><span class="line">         Console.WriteLine(&quot;油漆总成本： $&#123;0&#125;&quot; , Rect.getCost(area));</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总面积： 35</span><br><span class="line">油漆总成本： $2450</span><br></pre></td></tr></table></figure><h1 id="C-多态性"><a href="#C-多态性" class="headerlink" title="C# 多态性"></a>C# 多态性</h1><p><strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。</p><p>多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，函数的响应是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p><h2 id="静态多态性"><a href="#静态多态性" class="headerlink" title="静态多态性"></a>静态多态性</h2><p>在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p><ul><li>函数重载</li><li>运算符重载</li></ul><p>运算符重载将在下一章节讨论，接下来我们将讨论函数重载</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。</p><p>下面的实例演示了几个相同的函数 <strong>print()</strong>，用于打印不同的数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Printdata</span><br><span class="line">   &#123;</span><br><span class="line">      void print(int i)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing int: &#123;0&#125;&quot;, i );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      void print(double f)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing float: &#123;0&#125;&quot; , f);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      void print(string s)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing string: &#123;0&#125;&quot;, s);</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Printdata p = new Printdata();</span><br><span class="line">         // 调用 print 来打印整数</span><br><span class="line">         p.print(5);</span><br><span class="line">         // 调用 print 来打印浮点数</span><br><span class="line">         p.print(500.263);</span><br><span class="line">         // 调用 print 来打印字符串</span><br><span class="line">         p.print(&quot;Hello C++&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Printing int: 5</span><br><span class="line">Printing float: 500.263</span><br><span class="line">Printing string: Hello C++</span><br></pre></td></tr></table></figure><h2 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h2><p>C# 允许您使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><p>请注意，下面是有关抽象类的一些规则：</p><ul><li>您不能创建一个抽象类的实例。</li><li>您不能在一个抽象类外部声明一个抽象方法。</li><li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   abstract class Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public abstract int area();</span><br><span class="line">   &#125;</span><br><span class="line">   class Rectangle:  Shape</span><br><span class="line">   &#123;</span><br><span class="line">      private int length;</span><br><span class="line">      private int width;</span><br><span class="line">      public Rectangle( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         length = a;</span><br><span class="line">         width = b;</span><br><span class="line">      &#125;</span><br><span class="line">      public override int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         Console.WriteLine(&quot;Rectangle 类的面积：&quot;);</span><br><span class="line">         return (width * length); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle r = new Rectangle(10, 7);</span><br><span class="line">         double a = r.area();</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;,a);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle 类的面积：</span><br><span class="line">面积： 70</span><br></pre></td></tr></table></figure><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用<strong>虚方法</strong>。虚方法是使用关键字 <strong>virtual</strong> 声明的。虚方法可以在不同的继承类中有不同的实现。对虚方法的调用是在运行时发生的。</p><p>动态多态性是通过 <strong>抽象类</strong> 和 <strong>虚方法</strong> 实现的。</p><p>下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      protected int width, height;</span><br><span class="line">      public Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      public virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;父类的面积：&quot;);</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Rectangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public Rectangle( int a=0, int b=0): base(a, b)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      public override int area ()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Rectangle 类的面积：&quot;);</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Triangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public Triangle(int a = 0, int b = 0): base(a, b)</span><br><span class="line">      &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      public override int area()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Triangle 类的面积：&quot;);</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Caller</span><br><span class="line">   &#123;</span><br><span class="line">      public void CallArea(Shape sh)</span><br><span class="line">      &#123;</span><br><span class="line">         int a;</span><br><span class="line">         a = sh.area();</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, a);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Caller c = new Caller();</span><br><span class="line">         Rectangle r = new Rectangle(10, 7);</span><br><span class="line">         Triangle t = new Triangle(10, 5);</span><br><span class="line">         c.CallArea(r);</span><br><span class="line">         c.CallArea(t);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rectangle 类的面积：</span><br><span class="line">面积：70</span><br><span class="line">Triangle 类的面积：</span><br><span class="line">面积：25</span><br></pre></td></tr></table></figure><h1 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C# 运算符重载"></a>C# 运算符重载</h1><p>您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 <strong>operator</strong> 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。</p><p>例如，请看下面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Box operator+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">   Box box = new Box();</span><br><span class="line">   box.length = b.length + c.length;</span><br><span class="line">   box.breadth = b.breadth + c.breadth;</span><br><span class="line">   box.height = b.height + c.height;</span><br><span class="line">   return box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数为用户自定义的类 Box 实现了加法运算符（+）。它把两个 Box 对象的属性相加，并返回相加后的 Box 对象。 </p><h2 id="运算符重载的实现"><a href="#运算符重载的实现" class="headerlink" title="运算符重载的实现"></a>运算符重载的实现</h2><p>下面的程序演示了完整的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorOvlApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Box</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;      // 长度</span><br><span class="line">      private double breadth;     // 宽度</span><br><span class="line">      private double height;      // 高度</span><br><span class="line"></span><br><span class="line">      public double getVolume()</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">         breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">         height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符来把两个 Box 对象相加</span><br><span class="line">      public static Box operator+ (Box b, Box c)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box = new Box();</span><br><span class="line">         box.length = b.length + c.length;</span><br><span class="line">         box.breadth = b.breadth + c.breadth;</span><br><span class="line">         box.height = b.height + c.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Box Box1 = new Box();         // 声明 Box1，类型为 Box</span><br><span class="line">         Box Box2 = new Box();         // 声明 Box2，类型为 Box</span><br><span class="line">         Box Box3 = new Box();         // 声明 Box3，类型为 Box</span><br><span class="line">         double volume = 0.0;          // 体积</span><br><span class="line"></span><br><span class="line">         // Box1 详述</span><br><span class="line">         Box1.setLength(6.0);</span><br><span class="line">         Box1.setBreadth(7.0);</span><br><span class="line">         Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">         // Box2 详述</span><br><span class="line">         Box2.setLength(12.0);</span><br><span class="line">         Box2.setBreadth(13.0);</span><br><span class="line">         Box2.setHeight(10.0);</span><br><span class="line"></span><br><span class="line">         // Box1 的体积</span><br><span class="line">         volume = Box1.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">         // Box2 的体积</span><br><span class="line">         volume = Box2.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">         // 把两个对象相加</span><br><span class="line">         Box3 = Box1 + Box2;</span><br><span class="line"></span><br><span class="line">         // Box3 的体积</span><br><span class="line">         volume = Box3.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box3 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br><span class="line">Box3 的体积： 5400</span><br></pre></td></tr></table></figure><h2 id="可重载和不可重载运算符"><a href="#可重载和不可重载运算符" class="headerlink" title="可重载和不可重载运算符"></a>可重载和不可重载运算符</h2><p>下表描述了 C# 中运算符重载的能力：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+, -, !, ~, ++, –</td><td>这些一元运算符只有一个操作数，且可以被重载。</td></tr><tr><td>+, -, *, /, %</td><td>这些二元运算符带有两个操作数，且可以被重载。</td></tr><tr><td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td><td>这些比较运算符可以被重载。</td></tr><tr><td>&amp;&amp;, \</td><td>\</td><td></td><td>这些条件逻辑运算符不能被直接重载。</td></tr><tr><td>+=, -=, *=, /=, %=</td><td>这些赋值运算符不能被重载。</td></tr><tr><td>=, ., ?:, -&gt;, new, is, sizeof, typeof</td><td>这些运算符不能被重载。</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>针对上述讨论，让我们扩展上面的实例，重载更多的运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorOvlApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       private double length;      // 长度</span><br><span class="line">       private double breadth;     // 宽度</span><br><span class="line">       private double height;      // 高度</span><br><span class="line">      </span><br><span class="line">       public double getVolume()</span><br><span class="line">       &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符来把两个 Box 对象相加</span><br><span class="line">      public static Box operator+ (Box b, Box c)</span><br><span class="line">      &#123;</span><br><span class="line">          Box box = new Box();</span><br><span class="line">          box.length = b.length + c.length;</span><br><span class="line">          box.breadth = b.breadth + c.breadth;</span><br><span class="line">          box.height = b.height + c.height;</span><br><span class="line">          return box;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public static bool operator == (Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length == rhs.length &amp;&amp; lhs.height == rhs.height </span><br><span class="line">             &amp;&amp; lhs.breadth == rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public static bool operator !=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length != rhs.length || lhs.height != rhs.height </span><br><span class="line">              || lhs.breadth != rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public static bool operator &lt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &lt; rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &lt; rhs.height &amp;&amp; lhs.breadth &lt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &gt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &gt; rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &lt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &lt;= rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &lt;= rhs.height &amp;&amp; lhs.breadth &lt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &gt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &gt;= rhs.length &amp;&amp; lhs.height </span><br><span class="line">             &gt;= rhs.height &amp;&amp; lhs.breadth &gt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public override string ToString()</span><br><span class="line">      &#123;</span><br><span class="line">          return String.Format(&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;, length, breadth, height);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">        Box Box1 = new Box();          // 声明 Box1，类型为 Box</span><br><span class="line">        Box Box2 = new Box();          // 声明 Box2，类型为 Box</span><br><span class="line">        Box Box3 = new Box();          // 声明 Box3，类型为 Box</span><br><span class="line">        Box Box4 = new Box();</span><br><span class="line">        double volume = 0.0;   // 体积</span><br><span class="line"></span><br><span class="line">        // Box1 详述</span><br><span class="line">        Box1.setLength(6.0);</span><br><span class="line">        Box1.setBreadth(7.0);</span><br><span class="line">        Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">        // Box2 详述</span><br><span class="line">        Box2.setLength(12.0);</span><br><span class="line">        Box2.setBreadth(13.0);</span><br><span class="line">        Box2.setHeight(10.0);</span><br><span class="line"></span><br><span class="line">       // 使用重载的 ToString() 显示两个盒子</span><br><span class="line">        Console.WriteLine(&quot;Box1： &#123;0&#125;&quot;, Box1.ToString());</span><br><span class="line">        Console.WriteLine(&quot;Box2： &#123;0&#125;&quot;, Box2.ToString());</span><br><span class="line">        </span><br><span class="line">        // Box1 的体积</span><br><span class="line">        volume = Box1.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        // Box2 的体积</span><br><span class="line">        volume = Box2.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        // 把两个对象相加</span><br><span class="line">        Box3 = Box1 + Box2;</span><br><span class="line">        Console.WriteLine(&quot;Box3： &#123;0&#125;&quot;, Box3.ToString());</span><br><span class="line">        // Box3 的体积</span><br><span class="line">        volume = Box3.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box3 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        //comparing the boxes</span><br><span class="line">        if (Box1 &gt; Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 大于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不大于 Box2&quot;);</span><br><span class="line">        if (Box1 &lt; Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 小于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不小于 Box2&quot;);</span><br><span class="line">        if (Box1 &gt;= Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 大于等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不大于等于 Box2&quot;);</span><br><span class="line">        if (Box1 &lt;= Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 小于等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不小于等于 Box2&quot;);</span><br><span class="line">        if (Box1 != Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 不等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 等于 Box2&quot;);</span><br><span class="line">        Box4 = Box3;</span><br><span class="line">        if (Box3 == Box4)</span><br><span class="line">          Console.WriteLine(&quot;Box3 等于 Box4&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box3 不等于 Box4&quot;);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Box1： (6, 7, 5)</span><br><span class="line">Box2： (12, 13, 10)</span><br><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br><span class="line">Box3： (18, 20, 15)</span><br><span class="line">Box3 的体积： 5400</span><br><span class="line">Box1 不大于 Box2</span><br><span class="line">Box1 小于 Box2</span><br><span class="line">Box1 不大于等于 Box2</span><br><span class="line">Box1 小于等于 Box2</span><br><span class="line">Box1 不等于 Box2</span><br><span class="line">Box3 等于 Box4</span><br></pre></td></tr></table></figure><h1 id="C-接口（Interface）"><a href="#C-接口（Interface）" class="headerlink" title="C# 接口（Interface）"></a>C# 接口（Interface）</h1><p>接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。</p><p>接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。</p><p>接口使得实现接口的类或结构在形式上保持一致。</p><p>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。</p><h2 id="定义接口-MyInterface-cs"><a href="#定义接口-MyInterface-cs" class="headerlink" title="定义接口: MyInterface.cs"></a>定义接口: MyInterface.cs</h2><p>接口使用 <strong>interface</strong> 关键字声明，它与类的声明类似。接口声明默认是 public 的。下面是一个接口声明的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了接口 IMyInterface。通常接口命令以 I 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然我们可以按照需求设置参数和返回值。</p><p>值得注意的是，该方法并没有具体的实现。</p><h3 id="接下来我们来实现以上接口：InterfaceImplementer-cs"><a href="#接下来我们来实现以上接口：InterfaceImplementer-cs" class="headerlink" title="接下来我们来实现以上接口：InterfaceImplementer.cs"></a>接下来我们来实现以上接口：InterfaceImplementer.cs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    // 接口成员</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterfaceImplementer : IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MethodToImplement()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MethodToImplement() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class InterfaceImplementer : IMyInterface</span><br></pre></td></tr></table></figure><p>继承接口后，我们需要实现接口的方法 MethodToImplement() , 方法名必须与接口定义的方法名一致。</p><h2 id="接口继承-InterfaceInheritance-cs"><a href="#接口继承-InterfaceInheritance-cs" class="headerlink" title="接口继承: InterfaceInheritance.cs"></a>接口继承: InterfaceInheritance.cs</h2><p>以下实例定义了两个接口 IMyInterface 和 IParentInterface。</p><p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。</p><p>以下实例 IMyInterface 继承了 IParentInterface 接口，因此接口实现类必须实现 MethodToImplement() 和 ParentInterfaceMethod() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">interface IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">    void ParentInterfaceMethod();</span><br><span class="line">&#125;</span><br><span class="line">interface IMyInterface:IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line">class InterfaceImplementer:IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">    InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">    iImp.MethodToImplement();</span><br><span class="line">    iImp.ParentInterfaceMethod();;</span><br><span class="line">    &#125;</span><br><span class="line">    public void MethodToImplement()</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;MethodToImplement() called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void ParentInterfaceMethod()</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;ParentInterfaceMethod() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodToImplement() called.</span><br><span class="line">ParentInterfaceMethod() called.</span><br></pre></td></tr></table></figure><p>接口注意的几点：</p><ol><li>接口方法不能用public abstract等修饰。接口内不能有字段变量，构造函数。</li><li>接口内可以定义属性（有get和set的方法）。如string color { get ; set ; }这种。</li><li>实现接口时，必须和接口的格式一致。</li><li>必须实现接口的所有方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-继承&quot;&gt;&lt;a href=&quot;#C-继承&quot; class=&quot;headerlink&quot; title=&quot;C# 继承&quot;&gt;&lt;/a&gt;C# 继承&lt;/h1&gt;&lt;p&gt;继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(12)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-12/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-12/</id>
    <published>2018-06-26T05:29:27.000Z</published>
    <updated>2018-06-26T05:59:48.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类（Class）"><a href="#C-类（Class）" class="headerlink" title="C# 类（Class）"></a>C# 类（Class）</h1><p>当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量成为类的成员。 </p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类的定义是以关键字 <strong>class</strong> 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; class  class_name </span><br><span class="line">&#123;</span><br><span class="line">    // member variables</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    // member methods</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>访问标识符 <access specifier=""> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</access></li><li>数据类型 <data type=""> 指定了变量的类型，返回类型 <return type=""> 指定了返回的方法返回的数据类型。</return></data></li><li>如果要访问类的成员，你要使用点（.）运算符。</li><li>点运算符链接了对象的名称和成员的名称。</li></ul><p>下面的实例说明了目前为止所讨论的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace BoxApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       public double length;   // 长度</span><br><span class="line">       public double breadth;  // 宽度</span><br><span class="line">       public double height;   // 高度</span><br><span class="line">    &#125;</span><br><span class="line">    class Boxtester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = new Box();        // 声明 Box1，类型为 Box</span><br><span class="line">            Box Box2 = new Box();        // 声明 Box2，类型为 Box</span><br><span class="line">            double volume = 0.0;         // 体积</span><br><span class="line"></span><br><span class="line">            // Box1 详述</span><br><span class="line">            Box1.height = 5.0;</span><br><span class="line">            Box1.length = 6.0;</span><br><span class="line">            Box1.breadth = 7.0;</span><br><span class="line"></span><br><span class="line">            // Box2 详述</span><br><span class="line">            Box2.height = 10.0;</span><br><span class="line">            Box2.length = 12.0;</span><br><span class="line">            Box2.breadth = 13.0;</span><br><span class="line">           </span><br><span class="line">            // Box1 的体积</span><br><span class="line">            volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class="line">            Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;,  volume);</span><br><span class="line"></span><br><span class="line">            // Box2 的体积</span><br><span class="line">            volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class="line">            Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br></pre></td></tr></table></figure><h2 id="成员函数和封装"><a href="#成员函数和封装" class="headerlink" title="成员函数和封装"></a>成员函数和封装</h2><p>类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。</p><p>成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。</p><p>让我们使用上面的概念来设置和获取一个类中不同的类成员的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace BoxApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       private double length;   // 长度</span><br><span class="line">       private double breadth;  // 宽度</span><br><span class="line">       private double height;   // 高度</span><br><span class="line">       public void setLength( double len )</span><br><span class="line">       &#123;</span><br><span class="line">            length = len;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setBreadth( double bre )</span><br><span class="line">       &#123;</span><br><span class="line">            breadth = bre;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setHeight( double hei )</span><br><span class="line">       &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">       &#125;</span><br><span class="line">       public double getVolume()</span><br><span class="line">       &#123;</span><br><span class="line">           return length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Boxtester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = new Box();        // 声明 Box1，类型为 Box</span><br><span class="line">            Box Box2 = new Box();         // 声明 Box2，类型为 Box</span><br><span class="line">            double volume;                 // 体积</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // Box1 详述</span><br><span class="line">            Box1.setLength(6.0);</span><br><span class="line">            Box1.setBreadth(7.0);</span><br><span class="line">            Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">            // Box2 详述</span><br><span class="line">            Box2.setLength(12.0);</span><br><span class="line">            Box2.setBreadth(13.0);</span><br><span class="line">            Box2.setHeight(10.0);</span><br><span class="line">       </span><br><span class="line">            // Box1 的体积</span><br><span class="line">            volume = Box1.getVolume();</span><br><span class="line">            Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot; ,volume);</span><br><span class="line"></span><br><span class="line">            // Box2 的体积</span><br><span class="line">            volume = Box2.getVolume();</span><br><span class="line">            Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">           </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br></pre></td></tr></table></figure><h2 id="C-中的构造函数"><a href="#C-中的构造函数" class="headerlink" title="C# 中的构造函数"></a>C# 中的构造函数</h2><p>类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。</p><p>构造函数的名称与类的名称完全相同，它没有任何返回类型。</p><p>下面的实例说明了构造函数的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line();    </span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象已创建</span><br><span class="line">线条的长度： 6</span><br></pre></td></tr></table></figure><p><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。这种技术可以帮助你在创建对象的同时给对象赋初始值，具体请看下面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line(double len)  // 参数化构造函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建，length = &#123;0&#125;&quot;, len);</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line(10.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength()); </span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength()); </span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象已创建，length = 10</span><br><span class="line">线条的长度： 10</span><br><span class="line">线条的长度： 6</span><br></pre></td></tr></table></figure><h2 id="C-中的析构函数"><a href="#C-中的析构函数" class="headerlink" title="C# 中的析构函数"></a>C# 中的析构函数</h2><p>类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。</p><p>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p><p>下面的实例说明了析构函数的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line()  // 构造函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      ~Line() //析构函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已删除&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line();</span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength());           </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象已创建</span><br><span class="line">线条的长度： 6</span><br><span class="line">对象已删除</span><br></pre></td></tr></table></figure><h2 id="C-类的静态成员"><a href="#C-类的静态成员" class="headerlink" title="C# 类的静态成员"></a>C# 类的静态成员</h2><p>我们可以使用 <strong>static</strong> 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。</p><p>关键字 <strong>static</strong> 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。你也可以在类的定义内部初始化静态变量。</p><p>下面的实例演示了<strong>静态变量</strong>的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StaticVarApplication</span><br><span class="line">&#123;</span><br><span class="line">    class StaticVar</span><br><span class="line">    &#123;</span><br><span class="line">       public static int num;</span><br><span class="line">        public void count()</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        public int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class StaticTester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            StaticVar s1 = new StaticVar();</span><br><span class="line">            StaticVar s2 = new StaticVar();</span><br><span class="line">            s1.count();</span><br><span class="line">            s1.count();</span><br><span class="line">            s1.count();</span><br><span class="line">            s2.count();</span><br><span class="line">            s2.count();</span><br><span class="line">            s2.count();         </span><br><span class="line">            Console.WriteLine(&quot;s1 的变量 num： &#123;0&#125;&quot;, s1.getNum());</span><br><span class="line">            Console.WriteLine(&quot;s2 的变量 num： &#123;0&#125;&quot;, s2.getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 的变量 num： 6</span><br><span class="line">s2 的变量 num： 6</span><br></pre></td></tr></table></figure><p>你也可以把一个<strong>成员函数</strong>声明为 <strong>static</strong>。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。下面的实例演示了<strong>静态函数</strong>的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StaticVarApplication</span><br><span class="line">&#123;</span><br><span class="line">    class StaticVar</span><br><span class="line">    &#123;</span><br><span class="line">       public static int num;</span><br><span class="line">        public void count()</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        public static int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class StaticTester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            StaticVar s = new StaticVar();</span><br><span class="line">            s.count();</span><br><span class="line">            s.count();</span><br><span class="line">            s.count();                   </span><br><span class="line">            Console.WriteLine(&quot;变量 num： &#123;0&#125;&quot;, StaticVar.getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 num： 3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-类（Class）&quot;&gt;&lt;a href=&quot;#C-类（Class）&quot; class=&quot;headerlink&quot; title=&quot;C# 类（Class）&quot;&gt;&lt;/a&gt;C# 类（Class）&lt;/h1&gt;&lt;p&gt;当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(11)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-11/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-11/</id>
    <published>2018-06-26T04:24:38.000Z</published>
    <updated>2018-06-26T05:33:30.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-结构体（Struct）"><a href="#C-结构体（Struct）" class="headerlink" title="C# 结构体（Struct）"></a>C# 结构体（Struct）</h1><p>在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<strong>struct</strong> 关键字用于创建结构体。</p><p>结构体是用来代表一个记录。假设您想跟踪图书馆中书的动态。您可能想跟踪每本书的以下属性：</p><ul><li>Title</li><li>Author</li><li>Subject</li><li>Book ID</li></ul><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>为了定义一个结构体，您必须使用 struct 语句。struct 语句为程序定义了一个带有多个成员的新的数据类型。</p><p>例如，您可以按照如下的方式声明 Book 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   public string title;</span><br><span class="line">   public string author;</span><br><span class="line">   public string subject;</span><br><span class="line">   public int book_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的程序演示了结构的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">     </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   public string title;</span><br><span class="line">   public string author;</span><br><span class="line">   public string subject;</span><br><span class="line">   public int book_id;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">public class testStructure</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1;        /* 声明 Book1，类型为 Book */</span><br><span class="line">      Books Book2;        /* 声明 Book2，类型为 Book */</span><br><span class="line"></span><br><span class="line">      /* book 1 详述 */</span><br><span class="line">      Book1.title = &quot;C Programming&quot;;</span><br><span class="line">      Book1.author = &quot;Nuha Ali&quot;; </span><br><span class="line">      Book1.subject = &quot;C Programming Tutorial&quot;;</span><br><span class="line">      Book1.book_id = 6495407;</span><br><span class="line"></span><br><span class="line">      /* book 2 详述 */</span><br><span class="line">      Book2.title = &quot;Telecom Billing&quot;;</span><br><span class="line">      Book2.author = &quot;Zara Ali&quot;;</span><br><span class="line">      Book2.subject =  &quot;Telecom Billing Tutorial&quot;;</span><br><span class="line">      Book2.book_id = 6495700;</span><br><span class="line"></span><br><span class="line">      /* 打印 Book1 信息 */</span><br><span class="line">      Console.WriteLine( &quot;Book 1 title : &#123;0&#125;&quot;, Book1.title);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 author : &#123;0&#125;&quot;, Book1.author);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 subject : &#123;0&#125;&quot;, Book1.subject);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 book_id :&#123;0&#125;&quot;, Book1.book_id);</span><br><span class="line"></span><br><span class="line">      /* 打印 Book2 信息 */</span><br><span class="line">      Console.WriteLine(&quot;Book 2 title : &#123;0&#125;&quot;, Book2.title);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 author : &#123;0&#125;&quot;, Book2.author);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 subject : &#123;0&#125;&quot;, Book2.subject);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 book_id : &#123;0&#125;&quot;, Book2.book_id);       </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-结构的特点"><a href="#C-结构的特点" class="headerlink" title="C# 结构的特点"></a>C# 结构的特点</h2><p>您已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：</p><ul><li>结构可带有方法、字段、索引、属性、运算符方法和事件。</li><li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义默认的构造函数。默认的构造函数是自动定义的，且不能被改变。</li><li>与类不同，结构不能继承其他的结构或类。</li><li>结构不能作为其他结构或类的基础结构。</li><li>结构可实现一个或多个接口。</li><li>结构成员不能指定为 abstract、virtual 或 protected。</li><li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li><li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><h2 id="类-vs-结构"><a href="#类-vs-结构" class="headerlink" title="类 vs 结构"></a>类 vs 结构</h2><p>类和结构有以下几个基本的不同点：</p><ul><li>类是引用类型，结构是值类型。</li><li>结构不支持继承。</li><li>结构不能声明默认的构造函数。</li></ul><p>针对上述讨论，让我们重写前面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">     </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   private string title;</span><br><span class="line">   private string author;</span><br><span class="line">   private string subject;</span><br><span class="line">   private int book_id;</span><br><span class="line">   public void getValues(string t, string a, string s, int id)</span><br><span class="line">   &#123;</span><br><span class="line">      title = t;</span><br><span class="line">      author = a;</span><br><span class="line">      subject = s;</span><br><span class="line">      book_id =id; </span><br><span class="line">   &#125;</span><br><span class="line">   public void display()</span><br><span class="line">   &#123;</span><br><span class="line">      Console.WriteLine(&quot;Title : &#123;0&#125;&quot;, title);</span><br><span class="line">      Console.WriteLine(&quot;Author : &#123;0&#125;&quot;, author);</span><br><span class="line">      Console.WriteLine(&quot;Subject : &#123;0&#125;&quot;, subject);</span><br><span class="line">      Console.WriteLine(&quot;Book_id :&#123;0&#125;&quot;, book_id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">public class testStructure</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1 = new Books(); /* 声明 Book1，类型为 Book */</span><br><span class="line">      Books Book2 = new Books(); /* 声明 Book2，类型为 Book */</span><br><span class="line"></span><br><span class="line">      /* book 1 详述 */</span><br><span class="line">      Book1.getValues(&quot;C Programming&quot;,</span><br><span class="line">      &quot;Nuha Ali&quot;, &quot;C Programming Tutorial&quot;,6495407);</span><br><span class="line"></span><br><span class="line">      /* book 2 详述 */</span><br><span class="line">      Book2.getValues(&quot;Telecom Billing&quot;,</span><br><span class="line">      &quot;Zara Ali&quot;, &quot;Telecom Billing Tutorial&quot;, 6495700);</span><br><span class="line"></span><br><span class="line">      /* 打印 Book1 信息 */</span><br><span class="line">      Book1.display();</span><br><span class="line"></span><br><span class="line">      /* 打印 Book2 信息 */</span><br><span class="line">      Book2.display(); </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Title : C Programming</span><br><span class="line">Author : Nuha Ali</span><br><span class="line">Subject : C Programming Tutorial</span><br><span class="line">Book_id : 6495407</span><br><span class="line">Title : Telecom Billing</span><br><span class="line">Author : Zara Ali</span><br><span class="line">Subject : Telecom Billing Tutorial</span><br><span class="line">Book_id : 6495700</span><br></pre></td></tr></table></figure><h1 id="C-枚举（Enum）"><a href="#C-枚举（Enum）" class="headerlink" title="C# 枚举（Enum）"></a>C# 枚举（Enum）</h1><p>枚举是一组命名整型常量。枚举类型是使用 <strong>enum</strong> 关键字声明的。</p><p>C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。</p><h2 id="声明-enum-变量"><a href="#声明-enum-变量" class="headerlink" title="声明 enum 变量"></a>声明 <em>enum</em> 变量</h2><p>声明枚举的一般语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &lt;enum_name&gt;</span><br><span class="line">&#123; </span><br><span class="line">    enumeration list </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><em>enum_name</em> 指定枚举的类型名称。</li><li><em>enumeration list</em> 是一个用逗号分隔的标识符列表。</li></ul><p>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了枚举变量的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace EnumApplication</span><br><span class="line">&#123;</span><br><span class="line">   class EnumProgram</span><br><span class="line">   &#123;</span><br><span class="line">      enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int WeekdayStart = (int)Days.Mon;</span><br><span class="line">         int WeekdayEnd = (int)Days.Fri;</span><br><span class="line">         Console.WriteLine(&quot;Monday: &#123;0&#125;&quot;, WeekdayStart);</span><br><span class="line">         Console.WriteLine(&quot;Friday: &#123;0&#125;&quot;, WeekdayEnd);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monday: 1</span><br><span class="line">Friday: 5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-结构体（Struct）&quot;&gt;&lt;a href=&quot;#C-结构体（Struct）&quot; class=&quot;headerlink&quot; title=&quot;C# 结构体（Struct）&quot;&gt;&lt;/a&gt;C# 结构体（Struct）&lt;/h1&gt;&lt;p&gt;在 C# 中，结构体是值类型数据结构。它使得一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(10)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-10/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-10/</id>
    <published>2018-06-26T03:51:49.000Z</published>
    <updated>2018-06-26T04:24:59.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-数组（Array）"><a href="#C-数组（Array）" class="headerlink" title="C# 数组（Array）"></a>C# 数组（Array）</h1><p>数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p><p>声明数组变量并不是声明 number0、number1、…、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。</p><p>所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/04/arrays.jpg" alt="C# 中的数组"></p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在C#中声明一个数组，您可以使用下面的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datayype[] arrayName;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>datatype用于指定被存储在数组中的元素的类型。</li><li>[]指定数组的秩（维度）。秩指定数组的大小。</li><li>arrayName指定数组的名称。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance;</span><br></pre></td></tr></table></figure><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>声明一个数组不会在内存中初始化数组，当初始化数组变量时，您可以赋值给数组。</p><p>数组是一个引用类型，所以您需要使用 <strong>new</strong>关键字来创建数组的实例。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance = new double[10];</span><br></pre></td></tr></table></figure><h2 id="赋值给数组"><a href="#赋值给数组" class="headerlink" title="赋值给数组"></a>赋值给数组</h2><p>您可以通过使用索引号赋值给一个单独的数组元素，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance = &#123;2340.0,4523.69,3421.0&#125;</span><br></pre></td></tr></table></figure><p>您也可以创建并且初始化一个数组，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] marks = new int[5] &#123;99,98,92,97,95&#125;;</span><br></pre></td></tr></table></figure><p>在上述情况下，你也可以忽略数组的大小，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] marks = new int[] &#123;99,98,92,97,95&#125;;</span><br></pre></td></tr></table></figure><p>您也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] marks = new int[]  &#123; 99,  98, 92, 97, 95&#125;;</span><br><span class="line">int[] score = marks;</span><br></pre></td></tr></table></figure><p>当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>元素是通过带索引的数组名称来访问的。这是通过把元素的索引位置数组名称后的方括号中来实现的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double salary = balance[9];</span><br></pre></td></tr></table></figure><p>下面是一个实例，使用上面提到的三个概念，即声明、赋值、访问数组： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ArrayApplication</span><br><span class="line">&#123;</span><br><span class="line">    class MyArray</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int[] n = new int[10] ; /*n是一个带有10个整数的数组*/</span><br><span class="line">            int i,j;</span><br><span class="line">            /*初始化数组n中的元素*/</span><br><span class="line">            for(i=0;i&lt;10;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                n[i] = i+100;</span><br><span class="line">            &#125;</span><br><span class="line">            /*输出每个数组元素的值*/</span><br><span class="line">            for(j=0;j&lt;10;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;,j,n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h2 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h2><p>在前面的实例中，我们使用一个 for 循环来访问每个数组元素。您也可以使用一个 <strong>foreach</strong> 语句来遍历数组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ArrayApplication</span><br><span class="line">&#123;</span><br><span class="line">    class MyArray</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">             int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         /* 初始化数组 n 中的元素 */         </span><br><span class="line">         for ( int i = 0; i &lt; 10; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[i] = i + 100;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         /* 输出每个数组元素的值 */</span><br><span class="line">         foreach (int j in n )</span><br><span class="line">         &#123;</span><br><span class="line">            int i = j-100;</span><br><span class="line">            Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;, i, j);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h2 id="C-数组细节"><a href="#C-数组细节" class="headerlink" title="C# 数组细节"></a>C# 数组细节</h2><p>在 C# 中，数组是非常重要的，且需要了解更多的细节。下面列出了 C# 程序员必须清楚的一些与数组相关的重要概念：</p><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-multi-dimensional-arrays.html" target="_blank" rel="noopener">多维数组</a></td><td>C# 支持多维数组。多维数组最简单的形式是二维数组。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-jagged-arrays.html" target="_blank" rel="noopener">交错数组</a></td><td>C# 支持交错数组，即数组的数组。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-passing-arrays-to-functions.html" target="_blank" rel="noopener">传递数组给函数</a></td><td>您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-param-arrays.html" target="_blank" rel="noopener">参数数组</a></td><td>这通常用于传递未知数量的参数给函数。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-array-class.html" target="_blank" rel="noopener">Array 类</a></td><td>在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。</td></tr></tbody></table><h1 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h1><p>在 C# 中，您可以使用字符数组来表示字符串，但是，更常见的做法是使用 <strong>string</strong> 关键字来声明一个字符串变量。string 关键字是 <strong>System.String</strong> 类的别名。 </p><h2 id="创建-String-对象"><a href="#创建-String-对象" class="headerlink" title="创建 String 对象"></a>创建 String 对象</h2><p>您可以使用以下方法之一来创建 string 对象：</p><ul><li>通过给 String 变量指定一个字符串</li><li>通过使用 String 类构造函数</li><li>通过使用字符串串联运算符（ + ）</li><li>通过检索属性或调用一个返回字符串的方法</li><li>通过格式化方法来转换一个值或对象为它的字符串表示形式</li></ul><p>下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //字符串，字符串连接</span><br><span class="line">            string fname, lname;</span><br><span class="line">            fname = &quot;Rowan&quot;;</span><br><span class="line">            lname = &quot;Atkinson&quot;;</span><br><span class="line"></span><br><span class="line">            string fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(&quot;Full Name: &#123;0&#125;&quot;, fullname);</span><br><span class="line"></span><br><span class="line">            //通过使用 string 构造函数</span><br><span class="line">            char[] letters = &#123; &apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;,&apos;o&apos; &#125;;</span><br><span class="line">            string greetings = new string(letters);</span><br><span class="line">            Console.WriteLine(&quot;Greetings: &#123;0&#125;&quot;, greetings);</span><br><span class="line"></span><br><span class="line">            //方法返回字符串</span><br><span class="line">            string[] sarray = &#123; &quot;Hello&quot;, &quot;From&quot;, &quot;Tutorials&quot;, &quot;Point&quot; &#125;;</span><br><span class="line">            string message = String.Join(&quot; &quot;, sarray);</span><br><span class="line">            Console.WriteLine(&quot;Message: &#123;0&#125;&quot;, message);</span><br><span class="line"></span><br><span class="line">            //用于转化值的格式化方法</span><br><span class="line">            DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1);</span><br><span class="line">            string chat = String.Format(&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;, </span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(&quot;Message: &#123;0&#125;&quot;, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Full Name: RowanAtkinson</span><br><span class="line">Greetings: Hello</span><br><span class="line">Message: Hello From Tutorials Point</span><br><span class="line">Message: Message sent at 17:58 on Wednesday, 10 October 2012</span><br></pre></td></tr></table></figure><h2 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h2><p>String 类有以下两个属性：</p><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table><h2 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h2><p>String 类有许多方法用于 string 对象的操作。下面的表格提供了一些最常用的方法：</p><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator, string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table><p>上面的方法列表并不详尽，请访问 MSDN 库，查看完整的方法列表和 String 类构造函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了上面提到的一些方法：</p><p><strong>比较字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str1 = &quot;This is test&quot;;</span><br><span class="line">         string str2 = &quot;This is text&quot;;</span><br><span class="line"></span><br><span class="line">         if (String.Compare(str1, str2) == 0)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(str1 + &quot; and &quot; + str2 +  &quot; are equal.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(str1 + &quot; and &quot; + str2 + &quot; are not equal.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is test and This is text are not equal.</span><br></pre></td></tr></table></figure><p><strong>字符串包含字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str = &quot;This is test&quot;;</span><br><span class="line">         if (str.Contains(&quot;test&quot;))</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(&quot;The sequence &apos;test&apos; was found.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The sequence &apos;test&apos; was found.</span><br></pre></td></tr></table></figure><p><strong>获取子字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System; </span><br><span class="line">namespace StringApplication </span><br><span class="line">&#123;</span><br><span class="line">    class StringProg </span><br><span class="line">    &#123; </span><br><span class="line">        static void Main(string[] args) </span><br><span class="line">        &#123; </span><br><span class="line">            string str = &quot;Last night I dreamt of San Pedro&quot;; </span><br><span class="line">            Console.WriteLine(str); </span><br><span class="line">            string substr = str.Substring(23); </span><br><span class="line">            Console.WriteLine(substr); </span><br><span class="line">            Console.ReadKey() ; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last night I dreamt of San Pedro</span><br><span class="line">San Pedro</span><br></pre></td></tr></table></figure><p><strong>连接字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string[] starray = new string[]&#123;&quot;Down the way nights are dark&quot;,</span><br><span class="line">         &quot;And the sun shines daily on the mountain top&quot;,</span><br><span class="line">         &quot;I took a trip on a sailing ship&quot;,</span><br><span class="line">         &quot;And when I reached Jamaica&quot;,</span><br><span class="line">         &quot;I made a stop&quot;&#125;;</span><br><span class="line"></span><br><span class="line">         string str = String.Join(&quot;\n&quot;, starray);</span><br><span class="line">         Console.WriteLine(str);</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Down the way nights are dark</span><br><span class="line">And the sun shines daily on the mountain top</span><br><span class="line">I took a trip on a sailing ship</span><br><span class="line">And when I reached Jamaica</span><br><span class="line">I made a stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-数组（Array）&quot;&gt;&lt;a href=&quot;#C-数组（Array）&quot; class=&quot;headerlink&quot; title=&quot;C# 数组（Array）&quot;&gt;&lt;/a&gt;C# 数组（Array）&lt;/h1&gt;&lt;p&gt;数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-事件处理</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-事件处理/</id>
    <published>2018-06-26T03:26:35.000Z</published>
    <updated>2018-06-26T03:45:25.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用<code>v-on</code>指令监听DOM事件，并在粗发时运行一些Javascript代码。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter+=1"</span>&gt;</span></span><br><span class="line">        Add 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        The button above has been clicked &#123;&#123;counter&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el : <span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        counter:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><p>然而许多事件处理逻辑会更为复杂，所以直接把Javascript代码写在<code>v-on</code>指令中是不可行的。因此<code>v-on</code>还可以接收一个需要调用的方法名称。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--'greet' 是下面定义的方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span></span><br><span class="line">        Greet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        name:<span class="string">'Vue.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        greet:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">          alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">            <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">            <span class="keyword">if</span> (event) &#123;</span><br><span class="line">                alert(event.target.tagName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。 </p><blockquote><p>2.1.4 新增</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">组件事件</a>上。如果你还没有阅读关于组件的文档，现在大可不必担心。</p><blockquote><p>2.3.0 新增</p></blockquote><p>Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p><p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>记住所有的 <code>keyCode</code> 比较困难，所以 Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><h3 id="自动匹配按键修饰符"><a href="#自动匹配按键修饰符" class="headerlink" title="自动匹配按键修饰符"></a>自动匹配按键修饰符</h3><blockquote><p>2.5.0 新增</p></blockquote><p>你也可直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.page-down</span>=<span class="string">"onPageDown"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，处理函数仅在 <code>$event.key === &#39;PageDown&#39;</code> 时被调用。</p><p>有一些按键 (<code>.esc</code> 以及所有的方向键) 在 IE9 中有不同的 <code>key</code> 值, 如果你想支持 IE9，它们的内置别名应该是首选。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><blockquote><p>2.1.0 新增</p></blockquote><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><blockquote><p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p></blockquote><p>例如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。 </p><h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h3><blockquote><p>2.5.0 新增</p></blockquote><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p><h2 id="为什么在-HTML-中监听事件"><a href="#为什么在-HTML-中监听事件" class="headerlink" title="为什么在 HTML 中监听事件?"></a>为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事件处理&quot;&gt;&lt;a href=&quot;#事件处理&quot; class=&quot;headerlink&quot; title=&quot;事件处理&quot;&gt;&lt;/a&gt;事件处理&lt;/h1&gt;&lt;h2 id=&quot;监听事件&quot;&gt;&lt;a href=&quot;#监听事件&quot; class=&quot;headerlink&quot; title=&quot;监听事件&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-列表渲染</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-列表渲染/</id>
    <published>2018-06-26T02:18:38.000Z</published>
    <updated>2018-06-26T03:25:52.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="用v-for把一个数组对应为一组元素"><a href="#用v-for把一个数组对应为一组元素" class="headerlink" title="用v-for把一个数组对应为一组元素"></a>用<code>v-for</code>把一个数组对应为一组元素</h2><p>我们用<code>v-for</code>指令根据一组数组的选项列表进行渲染。<code>v-for</code>指令需要使用<code>item in items</code>形式的特殊语法，<code>items</code>是源数据数组并且<code>item</code>是数组元素迭代的别名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        items:[</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·Foo</span><br><span class="line">·Bar</span><br></pre></td></tr></table></figure><p>在<code>v-for</code>块中，我们拥有对父作用域属性的完全访问权限。<code>v-for</code>还支持一个可选的第二个参数为当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123;parentMessage&#125;&#125; - &#123;&#123;index&#125;&#125; - &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        parentMessage:<span class="string">'Parent'</span>,</span><br><span class="line">        items:[</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·Parent-0-Foo</span><br><span class="line">·Parent-1-Bar</span><br></pre></td></tr></table></figure><p>你也可以用<code>of</code>替代<code>in</code>作为分隔符，因为它是最接近Javascript迭代器的语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一个对象的-v-for"><a href="#一个对象的-v-for" class="headerlink" title="一个对象的 v-for"></a>一个对象的 <code>v-for</code></h2><p>你也可以用<code>v-for</code>通过一个对象的属性来迭代。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        object:&#123;</span><br><span class="line">            firstName:<span class="string">'John'</span>,</span><br><span class="line">            lastName:<span class="string">'Doe'</span>,</span><br><span class="line">            age:<span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">·John</span><br><span class="line">·Doe</span><br><span class="line">·30</span><br></pre></td></tr></table></figure><p>你也可以提供第二个的参数为键名： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstName:John</span><br><span class="line">lastName:Doe</span><br><span class="line">age:30</span><br></pre></td></tr></table></figure><p>第三参数为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.firstName:John</span><br><span class="line">1.lastName:Doe</span><br><span class="line">2.age:30</span><br></pre></td></tr></table></figure><p>在遍历对象时，是按 <code>Object.keys()</code> 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 </p><h2 id="key"><a href="#key" class="headerlink" title="key"></a><code>key</code></h2><p>当Vue.js用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用”就地复用”策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的数据，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似Vue 1.x的<code>track-by=&quot;$index&quot;</code></p><p>这个默认的模式是高效的，但是只适用于<strong>不依赖组件状态或临时DOM状态(例如：表单输入值)的列表渲染输出</strong>。</p><p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要每项提供一个唯一<code>key</code>属性。理想的<code>key</code>值是每项都有的且唯一的id。这个特殊的属性相当于Vue 1.x的<code>track-by</code>,但它的工作方式类似于一个属性，所以你需要用<code>v-bind</code>来绑定动态值(在这里使用简写):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议尽可能在使用<code>v-for</code>时提供<code>key</code>，除非遍历输出的DOM内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>因为它是Vue识别节点的一个通用机制，<code>key</code>并不是<code>v-for</code>特别关联，key还具有其他用途，我们将在后面的指南中看到其他用途。</p><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><p>你打开控制台，然后用前面例子的 <code>items</code> 数组调用变异方法：<code>example1.items.push({ message: &#39;Baz&#39; })</code> 。</p><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：<code>filter()</code>, <code>concat()</code> 和 <code>slice()</code> 。这些不会改变原始数组，但<strong>总是返回一个新数组</strong>。当使用非变异方法时，可以用新数组替换旧数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(function (item) &#123;</span><br><span class="line">  return item.message.match(/Foo/)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>vm.$set</code> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 <code>splice</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="对象更改检测注意事项"><a href="#对象更改检测注意事项" class="headerlink" title="对象更改检测注意事项"></a>对象更改检测注意事项</h2><p>还是由于 JavaScript 的限制，<strong>Vue 不能检测对象属性的添加或删除</strong>： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。例如，对于： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以添加一个新的 <code>age</code> 属性到嵌套的 <code>userProfile</code> 对象： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>vm.$set</code> 实例方法，它只是全局 <code>Vue.set</code> 的别名： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你应该这样做： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">        evenNumbers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number%<span class="number">2</span> === <span class="number">0</span> </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个 method 方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    even:<span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段取值范围的-v-for"><a href="#一段取值范围的-v-for" class="headerlink" title="一段取值范围的 v-for"></a>一段取值范围的 <code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h2 id="v-for-on-a-lt-template-gt"><a href="#v-for-on-a-lt-template-gt" class="headerlink" title="v-for on a &lt;template&gt;"></a><code>v-for</code> on a <code>&lt;template&gt;</code></h2><p>类似于<code>v-if</code>，你也可以利用带有<code>v-for</code>的<code>&lt;template&gt;</code>渲染多个元素。比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"></a><code>v-for</code> with <code>v-if</code></h2><p>当它们处于同一节点，<code>v-for</code>的优先级比<code>v-if</code>更高，这意味着<code>v-if</code>将分别重复运行每个<code>v-for</code>循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码只传递了未完成的 todos。 而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>)上。如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一个组件的-v-for"><a href="#一个组件的-v-for" class="headerlink" title="一个组件的 v-for"></a>一个组件的 <code>v-for</code></h2><p>了解组件相关知识，查看 <a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a>。完全可以先跳过它，以后再回来查看。 </p><p>在自定义组件里，你可以像任何普通元素一样用 <code>v-for</code> 。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.0+ 的版本里，当在组件中使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。 </p><p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 <code>props</code> ： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 </p><p>下面是一个简单的 todo list 的完整例子： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"addNewTodo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"new-todo"</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"new-todo"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">"E.g. Feed the cat"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>,&#123;</span><br><span class="line">    template:<span class="string">'&lt;li&gt;&#123;&#123;title&#125;&#125; &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;&lt;/li&gt;'</span>,</span><br><span class="line">    props:[<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        newTodoText:<span class="string">''</span>,</span><br><span class="line">        todos:[</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">1</span>,</span><br><span class="line">            title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">2</span>,</span><br><span class="line">            title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">3</span>,</span><br><span class="line">            title: <span class="string">'Mow the lawn'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        newTodoId:<span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        addNewTodo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">                id:<span class="keyword">this</span>.newTodoId++,</span><br><span class="line">                title:<span class="keyword">this</span>.newTodoText</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表渲染&quot;&gt;&lt;a href=&quot;#列表渲染&quot; class=&quot;headerlink&quot; title=&quot;列表渲染&quot;&gt;&lt;/a&gt;列表渲染&lt;/h1&gt;&lt;h2 id=&quot;用v-for把一个数组对应为一组元素&quot;&gt;&lt;a href=&quot;#用v-for把一个数组对应为一组元素&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-条件渲染</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-条件渲染/</id>
    <published>2018-06-26T01:57:46.000Z</published>
    <updated>2018-06-26T02:16:46.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if" target="_blank" rel="noopener"><code>v-if</code></a></h2><p>在字符串模板中，比如Handlebars，我们得像这样写一个条件块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handlebars 模板--&gt;</span></span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure><p>在Vue中，我们使用v-if指令实现同样的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">'ok'</span>&gt;</span></span><br><span class="line">    Yes</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    No</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-lt-template-gt-元素上使用v-if条件渲染分组"><a href="#在-lt-template-gt-元素上使用v-if条件渲染分组" class="headerlink" title="在&lt;template&gt;元素上使用v-if条件渲染分组"></a>在<code>&lt;template&gt;</code>元素上使用<code>v-if</code>条件渲染分组</h3><p>因为<code>v-if</code>是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个<code>&lt;template&gt;</code>元素当做不可见的包裹元素，并在上面使用<code>v-if</code>。最终的渲染结果包含<code>&lt;template&gt;</code>元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        Title</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Paragraph1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Paragraph2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h3><p>你可以使用<code>v-else</code>指令来表示<code>v-if</code>的”else块”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-else</code>元素必须紧跟在带有<code>v-if</code>或者<code>v-else-if</code>的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h3><p>2.1.0 新增 </p><p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。 </p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。 </p><p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> 属性即可： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> 属性。 </p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a><code>v-if</code> 与 <code>v-for</code> 一起使用</h2><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;条件渲染&quot;&gt;&lt;a href=&quot;#条件渲染&quot; class=&quot;headerlink&quot; title=&quot;条件渲染&quot;&gt;&lt;/a&gt;条件渲染&lt;/h1&gt;&lt;h2 id=&quot;v-if&quot;&gt;&lt;a href=&quot;#v-if&quot; class=&quot;headerlink&quot; title=&quot;v-if&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(9)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-9/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-9/</id>
    <published>2018-06-25T03:44:09.000Z</published>
    <updated>2018-06-26T01:57:59.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h1><h2 id="C-单问号-与-双问号"><a href="#C-单问号-与-双问号" class="headerlink" title="C# 单问号 ? 与 双问号 ??"></a>C# 单问号 ? 与 双问号 ??</h2><p>? : 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? i = 3 </span><br><span class="line">等同于</span><br><span class="line">Nullable&lt;int&gt; i = new Nullable&lt;int&gt;(3);</span><br><span class="line"></span><br><span class="line">int i; //默认值0</span><br><span class="line">int? ii; //默认值null</span><br></pre></td></tr></table></figure><p>?? : 双问号 可用于判断一个变量在为 null 时返回一个指定的值。</p><p>接下来我们详细说明。</p><h2 id="C-可空类型（Nullable）-1"><a href="#C-可空类型（Nullable）-1" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h2><p>C# 提供了一个特殊的数据类型，<strong>nullable</strong> 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p>例如，Nullable&lt; Int32 &gt;，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable&lt; bool &gt; 变量可以被赋值为 true 或 false 或 null。</p><p>在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。</p><p>声明一个 <strong>nullable</strong> 类型（可空类型）的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; data_type&gt; ? &lt;variable_name&gt; = null;</span><br></pre></td></tr></table></figure><p>下面的实例演示了可空数据类型的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int? num1 = null;</span><br><span class="line">         int? num2 = 45;</span><br><span class="line">         double? num3 = new double?();</span><br><span class="line">         double? num4 = 3.14157;</span><br><span class="line">         </span><br><span class="line">         bool? boolval = new bool?();</span><br><span class="line"></span><br><span class="line">         // 显示值</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;显示可空类型的值： &#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;, </span><br><span class="line">                            num1, num2, num3, num4);</span><br><span class="line">         Console.WriteLine(&quot;一个可空的布尔值： &#123;0&#125;&quot;, boolval);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">显示可空类型的值： , 45,  , 3.14157</span><br><span class="line">一个可空的布尔值：</span><br></pre></td></tr></table></figure><h2 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h2><p>Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。</p><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   &#123;</span><br><span class="line">         </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         </span><br><span class="line">         double? num1 = null;</span><br><span class="line">         double? num2 = 3.14157;</span><br><span class="line">         double num3;</span><br><span class="line">         num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34</span><br><span class="line">         Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);</span><br><span class="line">         num3 = num2 ?? 5.34;</span><br><span class="line">         Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num3 的值： 5.34</span><br><span class="line">num3 的值： 3.14157</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-可空类型（Nullable）&quot;&gt;&lt;a href=&quot;#C-可空类型（Nullable）&quot; class=&quot;headerlink&quot; title=&quot;C# 可空类型（Nullable）&quot;&gt;&lt;/a&gt;C# 可空类型（Nullable）&lt;/h1&gt;&lt;h2 id=&quot;C-单问号-与
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(8)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-8/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-8/</id>
    <published>2018-06-25T03:18:12.000Z</published>
    <updated>2018-06-25T03:42:49.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-方法"><a href="#C-方法" class="headerlink" title="C# 方法"></a>C# 方法</h1><p>一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个C#程序至少有一个带有Main方法的类。</p><p>要使用一个方法，您需要：</p><ul><li>定义方法</li><li>调用方法</li></ul><h2 id="C-中定义方法"><a href="#C-中定义方法" class="headerlink" title="C# 中定义方法"></a>C# 中定义方法</h2><p>当定义一个方法时，从根本上说是在声明它的结构的元素。在C#中，定义方法的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是方法的各个元素：</p><ul><li><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</li><li><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</li><li><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</li><li><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</li><li><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的代码片段显示一个函数 <em>FindMax</em>，它接受两个整数值，并返回两个中的较大值。它有 public 访问修饰符，所以它可以使用类的实例从类的外部进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class NumberManipulator</span><br><span class="line">&#123;</span><br><span class="line">   public int FindMax(int num1, int num2)</span><br><span class="line">   &#123;</span><br><span class="line">      /* 局部变量声明 */</span><br><span class="line">      int result;</span><br><span class="line"></span><br><span class="line">      if (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      else</span><br><span class="line">         result = num2;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h2><p>您可以使用方法名调用方法。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public int FindMax(int num1, int num2)</span><br><span class="line">      &#123;</span><br><span class="line">         /* 局部变量声明 */</span><br><span class="line">         int result;</span><br><span class="line"></span><br><span class="line">         if (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">         else</span><br><span class="line">            result = num2;</span><br><span class="line"></span><br><span class="line">         return result;</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         int b = 200;</span><br><span class="line">         int ret;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line"></span><br><span class="line">         //调用 FindMax 方法</span><br><span class="line">         ret = n.FindMax(a, b);</span><br><span class="line">         Console.WriteLine(&quot;最大值是： &#123;0&#125;&quot;, ret );</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是： 200</span><br></pre></td></tr></table></figure><p>您也可以使用类的实例从另一个类中调用其他类的公有方法。例如，方法 <em>FindMax</em>属于 <em>NumberManipulator</em> 类，您可以从另一个类 <em>Test</em> 中调用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public int FindMax(int num1, int num2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量声明 */</span><br><span class="line">            int result;</span><br><span class="line"></span><br><span class="line">            if (num1 &gt; num2)</span><br><span class="line">                result = num1;</span><br><span class="line">            else</span><br><span class="line">                result = num2;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量定义 */</span><br><span class="line">            int a = 100;</span><br><span class="line">            int b = 200;</span><br><span class="line">            int ret;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            //调用 FindMax 方法</span><br><span class="line">            ret = n.FindMax(a, b);</span><br><span class="line">            Console.WriteLine(&quot;最大值是： &#123;0&#125;&quot;, ret );</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是： 200</span><br></pre></td></tr></table></figure><h2 id="递归方法调用"><a href="#递归方法调用" class="headerlink" title="递归方法调用"></a>递归方法调用</h2><p>一个方法可以自我调用。这就是所谓的 <strong>递归</strong>。下面的实例使用递归函数计算一个数的阶乘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public int factorial(int num)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量定义 */</span><br><span class="line">            int result;</span><br><span class="line"></span><br><span class="line">            if (num == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                result = factorial(num - 1) * num;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            //调用 factorial 方法</span><br><span class="line">            Console.WriteLine(&quot;6 的阶乘是： &#123;0&#125;&quot;, n.factorial(6));</span><br><span class="line">            Console.WriteLine(&quot;7 的阶乘是： &#123;0&#125;&quot;, n.factorial(7));</span><br><span class="line">            Console.WriteLine(&quot;8 的阶乘是： &#123;0&#125;&quot;, n.factorial(8));</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 的阶乘是： 720</span><br><span class="line">7 的阶乘是： 5040</span><br><span class="line">8 的阶乘是： 40320</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当调用带有参数的方法时，您需要向方法传递参数。在 C# 中，有三种向方法传递参数的方式：</p><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>值参数</td><td>这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td></tr><tr><td>引用参数</td><td>这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td></tr><tr><td>输出参数</td><td>这种方式可以返回多个值。</td></tr></tbody></table><h2 id="按值传递参数"><a href="#按值传递参数" class="headerlink" title="按值传递参数"></a>按值传递参数</h2><p>这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。下面的实例演示了这个概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public void swap(int x, int y)</span><br><span class="line">      &#123;</span><br><span class="line">         int temp;</span><br><span class="line">         </span><br><span class="line">         temp = x; /* 保存 x 的值 */</span><br><span class="line">         x = y;    /* 把 y 赋值给 x */</span><br><span class="line">         y = temp; /* 把 temp 赋值给 y */</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         int b = 200;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);</span><br><span class="line">         </span><br><span class="line">         /* 调用函数来交换值 */</span><br><span class="line">         n.swap(a, b);</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);</span><br><span class="line">         </span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：100</span><br><span class="line">在交换之后，b 的值：200</span><br></pre></td></tr></table></figure><p>结果表明，即使在函数内改变了值，值也没有发生任何的变化。</p><h2 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h2><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculationApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public void  swap(ref int a,ref int b)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp ;</span><br><span class="line">            temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b =temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            </span><br><span class="line">            int a = 100;</span><br><span class="line">            int b = 200;</span><br><span class="line">            Console.WriteLine(&quot;交换前：a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            /*数据交换*/</span><br><span class="line">            n.swap(ref a,ref b);</span><br><span class="line">            Console.WriteLine(&quot;交换后：a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h2 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h2><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public void getValue(out int x )</span><br><span class="line">      &#123;</span><br><span class="line">         int temp = 5;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         </span><br><span class="line">         /* 调用函数来获取值 */</span><br><span class="line">         n.getValue(out a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculationApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public void  getVal(out int a,out int b)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Please enter the first number:&quot;);</span><br><span class="line">            a = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(&quot;Please enter the second number:&quot;);</span><br><span class="line">            b = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            </span><br><span class="line">            int a;</span><br><span class="line">            int b ;</span><br><span class="line">            /*数据输入*/</span><br><span class="line">            n.getVal(out a,out b);</span><br><span class="line">            Console.WriteLine(&quot;enter number : a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please enter the first number:</span><br><span class="line">7</span><br><span class="line">Please enter the second number:</span><br><span class="line">8</span><br><span class="line">enter number : a=7,b=8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-方法&quot;&gt;&lt;a href=&quot;#C-方法&quot; class=&quot;headerlink&quot; title=&quot;C# 方法&quot;&gt;&lt;/a&gt;C# 方法&lt;/h1&gt;&lt;p&gt;一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个C#程序至少有一个带有Main方法的类。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(7)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-7/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-7/</id>
    <published>2018-06-25T02:59:21.000Z</published>
    <updated>2018-06-25T03:17:24.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h1><p><strong>封装</strong>被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中“。在面向对象设计方法论中，封装是为了防止对实现细节的访问。</p><p>抽象和封装是面向对象设计的相关性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</p><p>C#封装根据具体的需要，设置使用者的访问权限，并通过<strong>访问修饰符</strong>来实现。</p><p>一个<strong>访问修饰符</strong>定义了一个类成员的范围和可见性。C#支持的访问修饰符如下所示：</p><ul><li>public：所有对象都可以访问；</li><li>private：对象本身在对象内部可以访问；</li><li>protected：只有该类对象及其子类对象可以访问；</li><li>internal：同一个程序集的对象可以访问；</li><li>protected internal：访问限于当前程序集或派生自包含类的类型</li></ul><h2 id="Public-访问修饰符"><a href="#Public-访问修饰符" class="headerlink" title="Public 访问修饰符"></a>Public 访问修饰符</h2><p>Public访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</p><p>下面的实例说明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        //成员变量</span><br><span class="line">        public double length;</span><br><span class="line">        public double width;</span><br><span class="line"></span><br><span class="line">        public double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;// Rectangle 结束</span><br><span class="line"></span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.length = 4.5;</span><br><span class="line">            r.width = 3.5;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 3.5</span><br><span class="line">面积： 15.75</span><br></pre></td></tr></table></figure><p>在上面的实例中，成员变量 length 和 width 被声明为 <strong>public</strong>，所以它们可以被函数 Main() 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><p>成员函数 <em>Display()</em> 和 <em>GetArea()</em> 可以直接访问这些变量。</p><p>成员函数 <em>Display()</em> 也被声明为 <strong>public</strong>，所以它也能被 <em>Main()</em> 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><h2 id="Private-访问修饰符"><a href="#Private-访问修饰符" class="headerlink" title="Private 访问修饰符"></a>Private 访问修饰符</h2><p>Private访问修饰符允许一个类将成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</p><p>下面实例说明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        //成员变量</span><br><span class="line">        private double length;</span><br><span class="line">        private double width;</span><br><span class="line"></span><br><span class="line">        public void Acceptdetails()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入长度：&quot;);</span><br><span class="line">            length = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(&quot;请输入宽度：&quot;);</span><br><span class="line">            width = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">        &#125;</span><br><span class="line">        public double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//end class Rectangle    </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.Acceptdetails();</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入长度：</span><br><span class="line">4.4</span><br><span class="line">请输入宽度：</span><br><span class="line">3.3</span><br><span class="line">长度： 4.4</span><br><span class="line">宽度： 3.3</span><br><span class="line">面积： 14.52</span><br></pre></td></tr></table></figure><p>在上面的实例中，成员变量 length 和 width 被声明为 <strong>private</strong>，所以它们不能被函数 Main() 访问。</p><p>成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 可以访问这些变量。</p><p>由于成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 被声明为 <strong>public</strong>，所以它们可以被 <em>Main()</em> 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><h2 id="Internal-访问修饰符"><a href="#Internal-访问修饰符" class="headerlink" title="Internal 访问修饰符"></a>Internal 访问修饰符</h2><p>Internal访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有internal访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。</p><p>下面的实例说明了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace Rectanglepplication</span><br><span class="line">&#123;</span><br><span class="line">     //成员变量</span><br><span class="line">        internal double length;</span><br><span class="line">        internal double width;</span><br><span class="line">        </span><br><span class="line">        double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">       public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//end class Rectangle    </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.length = 4.5;</span><br><span class="line">            r.width = 3.5;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 3.5</span><br><span class="line">面积： 15.75</span><br></pre></td></tr></table></figure><p>在上面的实例中，请注意成员函数 <em>GetArea()</em> 声明的时候不带有任何访问修饰符。如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 <strong>private</strong>。</p><h2 id="Protected-Internal-访问修饰符"><a href="#Protected-Internal-访问修饰符" class="headerlink" title="Protected Internal 访问修饰符"></a>Protected Internal 访问修饰符</h2><p>Protected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-封装&quot;&gt;&lt;a href=&quot;#C-封装&quot; class=&quot;headerlink&quot; title=&quot;C#封装&quot;&gt;&lt;/a&gt;C#封装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中“。在面向对象设计方法论中，封
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(6)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-6/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-6/</id>
    <published>2018-06-25T02:50:34.000Z</published>
    <updated>2018-06-25T02:58:56.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C# 判断"></a>C# 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><p>下面是大多数编程语言中典型的判断结构的一般形式：<img src="http://www.runoob.com/wp-content/uploads/2015/12/if.png" alt="C# 中的判断语句"></p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C# 提供了以下类型的判断语句。点击链接查看每个语句的细节。</p><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-if.html" target="_blank" rel="noopener">if 语句</a></td><td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-if-else.html" target="_blank" rel="noopener">if…else 语句</a></td><td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-if.html" target="_blank" rel="noopener">嵌套 if 语句</a></td><td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-switch.html" target="_blank" rel="noopener">switch 语句</a></td><td>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-switch.html" target="_blank" rel="noopener">嵌套 switch 语句</a></td><td>您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="? : 运算符"></a>? : 运算符</h2><p>我们已经在前面的章节中讲解了 <strong>条件运算符 ? :</strong>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure><p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p><p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C# 循环"></a>C# 循环</h1><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p><p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：<img src="http://www.runoob.com/wp-content/uploads/2014/04/loop_architecture.jpg" alt="循环结构"></p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>C# 提供了以下几种循环类型。点击链接查看每个类型的细节。</p><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-while-loop.html" target="_blank" rel="noopener">while 循环</a></td><td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-for-loop.html" target="_blank" rel="noopener">for/foreach 循环</a></td><td>多次执行一个语句序列，简化管理循环变量的代码。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-do-while-loop.html" target="_blank" rel="noopener">do…while 循环</a></td><td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-loops.html" target="_blank" rel="noopener">嵌套循环</a></td><td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr></tbody></table><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p><p>C# 提供了下列的控制语句。点击链接查看每个语句的细节。</p><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-break-statement.html" target="_blank" rel="noopener">break 语句</a></td><td>终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-continue-statement.html" target="_blank" rel="noopener">continue 语句</a></td><td>引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr></tbody></table><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace Loops</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            for (; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hey! I am Trapped&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，程序员偏向于使用 for(;;) 结构来表示一个无限循环。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-判断&quot;&gt;&lt;a href=&quot;#C-判断&quot; class=&quot;headerlink&quot; title=&quot;C# 判断&quot;&gt;&lt;/a&gt;C# 判断&lt;/h1&gt;&lt;p&gt;判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(5)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-5/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-5/</id>
    <published>2018-06-25T02:32:35.000Z</published>
    <updated>2018-06-25T02:50:01.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C# 运算符"></a>C# 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p>本教程将逐一讲解算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符及其他运算符。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表显示了 C# 支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>把两个操作数相加</td><td>A + B 将得到 30</td></tr><tr><td>-</td><td>从第一个操作数中减去第二个操作数</td><td>A - B 将得到 -10</td></tr><tr><td>*</td><td>把两个操作数相乘</td><td>A * B 将得到 200</td></tr><tr><td>/</td><td>分子除以分母</td><td>B / A 将得到 2</td></tr><tr><td>%</td><td>取模运算符，整除后的余数</td><td>B % A 将得到 0</td></tr><tr><td>++</td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 11</td></tr><tr><td>–</td><td>自减运算符，整数值减少 1</td><td>A– 将得到 9</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的算术运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 21;</span><br><span class="line">            int b = 10;</span><br><span class="line">            int c;</span><br><span class="line"></span><br><span class="line">            c = a + b;</span><br><span class="line">            Console.WriteLine(&quot;Line 1 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a - b;</span><br><span class="line">            Console.WriteLine(&quot;Line 2 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a * b;</span><br><span class="line">            Console.WriteLine(&quot;Line 3 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a / b;</span><br><span class="line">            Console.WriteLine(&quot;Line 4 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a % b;</span><br><span class="line">            Console.WriteLine(&quot;Line 5 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            // ++a 先进行自增运算再赋值</span><br><span class="line">            c = ++a;</span><br><span class="line">            Console.WriteLine(&quot;Line 6 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            // 此时 a 的值为 22</span><br><span class="line">            // --a 先进行自减运算再赋值</span><br><span class="line">            c = --a;</span><br><span class="line">            Console.WriteLine(&quot;Line 7 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - c 的值是 31</span><br><span class="line">Line 2 - c 的值是 11</span><br><span class="line">Line 3 - c 的值是 210</span><br><span class="line">Line 4 - c 的值是 2</span><br><span class="line">Line 5 - c 的值是 1</span><br><span class="line">Line 6 - c 的值是 22</span><br><span class="line">Line 7 - c 的值是 21</span><br></pre></td></tr></table></figure><ul><li><strong>c = a++</strong>: 先将 a 赋值给 c，再对 a 进行自增运算。</li><li><strong>c = ++a</strong>: 先将 a 进行自增运算，再将 a 赋值给 c 。</li><li><strong>c = a–</strong>: 先将 a 赋值给 c，再对 a 进行自减运算。</li><li><strong>c = –a</strong>: 先将 a 进行自减运算，再将 a 赋值给 c 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 1;</span><br><span class="line">            int b;</span><br><span class="line"></span><br><span class="line">            // a++ 先赋值再进行自增运算</span><br><span class="line">            b = a++;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // ++a 先进行自增运算再赋值</span><br><span class="line">            a = 1; // 重新初始化 a</span><br><span class="line">            b = ++a;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // a-- 先赋值再进行自减运算</span><br><span class="line">            a = 1;  // 重新初始化 a</span><br><span class="line">            b= a--;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // --a 先进行自减运算再赋值</span><br><span class="line">            a = 1;  // 重新初始化 a</span><br><span class="line">            b= --a;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = 1</span><br><span class="line">a = 2</span><br><span class="line">b = 2</span><br><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">a = 0</span><br><span class="line">b = 0</span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表显示了 C# 支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(A == B) 不为真。</td></tr><tr><td>!=</td><td>检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(A != B) 为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td>(A &gt; B) 不为真。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td>(A &lt; B) 为真。</td></tr><tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td>(A &gt;= B) 不为真。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td>(A &lt;= B) 为真。</td></tr></tbody></table><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的关系运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">  static void Main(string[] args)</span><br><span class="line">  &#123;</span><br><span class="line">      int a = 21;</span><br><span class="line">      int b = 10;</span><br><span class="line">      </span><br><span class="line">      if (a == b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 1 - a 等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 1 - a 不等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (a &lt; b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 2 - a 小于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 2 - a 不小于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (a &gt; b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 3 - a 大于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 3 - a 不大于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      /* 改变 a 和 b 的值 */</span><br><span class="line">      a = 5;</span><br><span class="line">      b = 20;</span><br><span class="line">      if (a &lt;= b)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Line 4 - a 小于或等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (b &gt;= a)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Line 5 - b 大于或等于 a&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - a 不等于 b</span><br><span class="line">Line 2 - a 不小于 b</span><br><span class="line">Line 3 - a 大于 b</span><br><span class="line">Line 4 - a 小于或等于 b</span><br><span class="line">Line 5 - b 大于或等于 a</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表显示了 C# 支持的所有逻辑运算符。假设变量 <strong>A</strong> 为布尔值 true，变量 <strong>B</strong> 为布尔值 false，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr><tr><td>\</td><td>\</td><td></td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A \</td><td>\</td><td>B) 为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr></tbody></table><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的逻辑运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            bool a = true;</span><br><span class="line">            bool b = true;</span><br><span class="line">           </span><br><span class="line">            if (a &amp;&amp; b)</span><br><span class="line">            &#123;</span><br><span class="line">               Console.WriteLine(&quot;Line 1 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (a || b)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 2 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /* 改变 a 和 b 的值 */</span><br><span class="line">            a = false;</span><br><span class="line">            b = true;</span><br><span class="line">            if (a &amp;&amp; b)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 3 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 3 - 条件不为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!(a &amp;&amp; b))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 4 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - 条件为真</span><br><span class="line">Line 2 - 条件为真</span><br><span class="line">Line 3 - 条件不为真</span><br><span class="line">Line 4 - 条件为真</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p \</th><th>q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><p>A = 0011 1100</p><p>B = 0000 1101</p><p>-—————-</p><p>A&amp;B = 0000 1100</p><p>A|B = 0011 1101</p><p>A^B = 0011 0001</p><p>~A  = 1100 0011</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>\</td><td></td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A \</td><td>B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的位运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 60;               /* 60 = 0011 1100 */  </span><br><span class="line">            int b = 13;               /* 13 = 0000 1101 */</span><br><span class="line">            int c = 0;           </span><br><span class="line"></span><br><span class="line">             c = a &amp; b;           /* 12 = 0000 1100 */ </span><br><span class="line">             Console.WriteLine(&quot;Line 1 - c 的值是 &#123;0&#125;&quot;, c );</span><br><span class="line"></span><br><span class="line">             c = a | b;           /* 61 = 0011 1101 */</span><br><span class="line">             Console.WriteLine(&quot;Line 2 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a ^ b;           /* 49 = 0011 0001 */</span><br><span class="line">             Console.WriteLine(&quot;Line 3 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = ~a;               /*-61 = 1100 0011 */</span><br><span class="line">             Console.WriteLine(&quot;Line 4 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a &lt;&lt; 2;     /* 240 = 1111 0000 */</span><br><span class="line">             Console.WriteLine(&quot;Line 5 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a &gt;&gt; 2;     /* 15 = 0000 1111 */</span><br><span class="line">             Console.WriteLine(&quot;Line 6 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - c 的值是 12</span><br><span class="line">Line 2 - c 的值是 61</span><br><span class="line">Line 3 - c 的值是 49</span><br><span class="line">Line 4 - c 的值是 -61</span><br><span class="line">Line 5 - c 的值是 240</span><br><span class="line">Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了 C# 支持的赋值运算符：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C <em>= A 相当于 C = C </em> A</td></tr><tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td>%=</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %= A 相当于 C = C % A</td></tr><tr><td>&lt;&lt;=</td><td>左移且赋值运算符</td><td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;=</td><td>右移且赋值运算符</td><td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与且赋值运算符</td><td>C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td>^=</td><td>按位异或且赋值运算符</td><td>C ^= 2 等同于 C = C ^ 2</td></tr><tr><td>\</td><td>=</td><td>按位或且赋值运算符</td><td>C \</td><td>= 2 等同于 C = C \</td><td>2</td></tr></tbody></table><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的赋值运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 21;</span><br><span class="line">            int c;</span><br><span class="line"></span><br><span class="line">            c = a;</span><br><span class="line">            Console.WriteLine(&quot;Line 1 - =  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c += a;</span><br><span class="line">            Console.WriteLine(&quot;Line 2 - += c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c -= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 3 - -=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c *= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 4 - *=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c /= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 5 - /=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c = 200;</span><br><span class="line">            c %= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 6 - %=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &lt;&lt;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 7 - &lt;&lt;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &gt;&gt;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 8 - &gt;&gt;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &amp;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 9 - &amp;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c ^= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 10 - ^=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c |= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 11 - |=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - =     c 的值 = 21</span><br><span class="line">Line 2 - +=    c 的值 = 42</span><br><span class="line">Line 3 - -=    c 的值 = 21</span><br><span class="line">Line 4 - *=    c 的值 = 441</span><br><span class="line">Line 5 - /=    c 的值 = 21</span><br><span class="line">Line 6 - %=    c 的值 = 11</span><br><span class="line">Line 7 - &lt;&lt;=    c 的值 = 44</span><br><span class="line">Line 8 - &gt;&gt;=    c 的值 = 11</span><br><span class="line">Line 9 - &amp;=    c 的值 = 2</span><br><span class="line">Line 10 - ^=    c 的值 = 0</span><br><span class="line">Line 11 - |=    c 的值 = 2</span><br></pre></td></tr></table></figure><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>下表列出了 C# 支持的其他一些重要的运算符，包括 <strong>sizeof</strong>、<strong>typeof</strong> 和 <strong>? :</strong>。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回数据类型的大小。</td><td>sizeof(int)，将返回 4.</td></tr><tr><td>typeof()</td><td>返回 class 的类型。</td><td>typeof(StreamReader);</td></tr><tr><td>&amp;</td><td>返回变量的地址。</td><td>&a; 将得到变量的实际地址。</td></tr><tr><td>*</td><td>变量的指针。</td><td>*a; 将指向一个变量。</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader;</td></tr></tbody></table><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         </span><br><span class="line">         /* sizeof 运算符的实例 */</span><br><span class="line">         Console.WriteLine(&quot;int 的大小是 &#123;0&#125;&quot;, sizeof(int));</span><br><span class="line">         Console.WriteLine(&quot;short 的大小是 &#123;0&#125;&quot;, sizeof(short));</span><br><span class="line">         Console.WriteLine(&quot;double 的大小是 &#123;0&#125;&quot;, sizeof(double));</span><br><span class="line">         </span><br><span class="line">         /* 三元运算符符的实例 */</span><br><span class="line">         int a, b;</span><br><span class="line">         a = 10;</span><br><span class="line">         b = (a == 1) ? 20 : 30;</span><br><span class="line">         Console.WriteLine(&quot;b 的值是 &#123;0&#125;&quot;, b);</span><br><span class="line"></span><br><span class="line">         b = (a == 10) ? 20 : 30;</span><br><span class="line">         Console.WriteLine(&quot;b 的值是 &#123;0&#125;&quot;, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int 的大小是 4</span><br><span class="line">short 的大小是 2</span><br><span class="line">double 的大小是 8</span><br><span class="line">b 的值是 30</span><br><span class="line">b 的值是 20</span><br></pre></td></tr></table></figure><h2 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C# 中的运算符优先级"></a>C# 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p><p>例如 x = 7 + 3 <em> 2，在这里，x 被赋值为 13，而不是 20，因为运算符 </em> 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* / %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr><tr><td>相等</td><td>== !=</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>\</td><td></td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>\</td><td>\</td><td></td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= \</td><td>=</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int a = 20;</span><br><span class="line">         int b = 10;</span><br><span class="line">         int c = 15;</span><br><span class="line">         int d = 5;</span><br><span class="line">         int e;</span><br><span class="line">         e = (a + b) * c / d;     // ( 30 * 15 ) / 5</span><br><span class="line">         Console.WriteLine(&quot;(a + b) * c / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = ((a + b) * c) / d;   // (30 * 15 ) / 5</span><br><span class="line">         Console.WriteLine(&quot;((a + b) * c) / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = (a + b) * (c / d);   // (30) * (15/5)</span><br><span class="line">         Console.WriteLine(&quot;(a + b) * (c / d) 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = a + (b * c) / d;    //  20 + (150/5)</span><br><span class="line">         Console.WriteLine(&quot;a + (b * c) / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) * c / d 的值是 90</span><br><span class="line">((a + b) * c) / d 的值是 90</span><br><span class="line">(a + b) * (c / d) 的值是 90</span><br><span class="line">a + (b * c) / d 的值是 50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-运算符&quot;&gt;&lt;a href=&quot;#C-运算符&quot; class=&quot;headerlink&quot; title=&quot;C# 运算符&quot;&gt;&lt;/a&gt;C# 运算符&lt;/h1&gt;&lt;p&gt;运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-Class与Style绑定</title>
    <link href="http://yoursite.com/2018/06/23/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/06/23/Vue的知识点积累-Class与Style绑定/</id>
    <published>2018-06-23T10:06:29.000Z</published>
    <updated>2018-06-23T10:11:13.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 </p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class" target="_blank" rel="noopener">绑定 HTML Class</a></h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">对象语法</a></h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据属性 <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">truthiness</a>。</p><p>你可以在对象中传入更多属性来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class 属性共存。当有如下模板:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code>的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">数组语法</a></h3><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1" target="_blank" rel="noopener">[1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A" target="_blank" rel="noopener">用在组件上</a></h3><blockquote><p>这个章节假设你已经对 <a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue 组件</a>有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p></blockquote><p>当在一个自定义组件上使用 <code>class</code> 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。</p><p>例如，如果你声明了这个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在使用它的时候添加一些 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">class</span>=<span class="string">"baz boo"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 将被渲染为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于带数据绑定 class 也同样适用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 truthy<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1" target="_blank" rel="noopener">[1]</a> 时，HTML 将被渲染成为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar active"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F" target="_blank" rel="noopener">绑定内联样式</a></h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1" target="_blank" rel="noopener">对象语法</a></h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1" target="_blank" rel="noopener">数组语法</a></h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80" target="_blank" rel="noopener">自动添加前缀</a></h3><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%A4%9A%E9%87%8D%E5%80%BC" target="_blank" rel="noopener">多重值</a></h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><p><strong>译者注</strong><br>[1] truthy 不是 <code>true</code>，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN</a> 的解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;p&gt;操作元素的 class 列表
      
    
    </summary>
    
    
  </entry>
  
</feed>
