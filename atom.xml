<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sonnypp</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-26T07:17:39.616Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SUE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#学习之路(14)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-14/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-14/</id>
    <published>2018-06-26T06:38:11.000Z</published>
    <updated>2018-06-26T07:17:39.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-命名空间（Namespace）"><a href="#C-命名空间（Namespace）" class="headerlink" title="C# 命名空间（Namespace）"></a>C# 命名空间（Namespace）</h1><p><strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 </p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>命名空间的定义是以关键字 <strong>namespace</strong> 开始，后跟命名空间的名称，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name</span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace_name.item_name;</span><br></pre></td></tr></table></figure><p>下面的程序演示了命名空间的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">    class namespace_c1</span><br><span class="line">    &#123;</span><br><span class="line">        public void func()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace second_space</span><br><span class="line">&#123;</span><br><span class="line">    class namespace_c2</span><br><span class="line">    &#123;</span><br><span class="line">        public void func()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Inside second_space&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        first_space.namespace_c1 fc = new first_space.namespace_c1();</span><br><span class="line">        second_space.namespace_c2 sc = new second_space.namespace_c2();</span><br><span class="line">        fc.func();</span><br><span class="line">        sc.func();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h2 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h2><p><strong>using</strong> 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 <strong>System</strong> 命名空间，其中定义了类 Console。我们可以只写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello there&quot;);</span><br></pre></td></tr></table></figure><p>我们可以写完全限定名称，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Console.WriteLine(&quot;Hello there&quot;);</span><br></pre></td></tr></table></figure><p>您也可以使用 <strong>using</strong> 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。下面的代码演示了命名空间的应用。</p><p>让我们使用 using 指定重写上面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using first_space;</span><br><span class="line">using second_space;</span><br><span class="line"></span><br><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">   class abc</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace second_space</span><br><span class="line">&#123;</span><br><span class="line">   class efg</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside second_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;   </span><br><span class="line">class TestClass</span><br><span class="line">&#123;</span><br><span class="line">   static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      abc fc = new abc();</span><br><span class="line">      efg sc = new efg();</span><br><span class="line">      fc.func();</span><br><span class="line">      sc.func();</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h2 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h2><p>命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 </span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 </span><br><span class="line">   &#123;</span><br><span class="line">     // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用点（.）运算符访问嵌套的命名空间的成员，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using SomeNameSpace;</span><br><span class="line">using SomeNameSpace.Nested;</span><br><span class="line"></span><br><span class="line">namespace SomeNameSpace</span><br><span class="line">&#123;</span><br><span class="line">    public class MyClass </span><br><span class="line">    &#123;</span><br><span class="line">        static void Main() </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;In SomeNameSpace&quot;);</span><br><span class="line">            Nested.NestedNameSpaceClass.SayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内嵌命名空间</span><br><span class="line">    namespace Nested   </span><br><span class="line">    &#123;</span><br><span class="line">        public class NestedNameSpaceClass </span><br><span class="line">        &#123;</span><br><span class="line">            public static void SayHello() </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;In Nested&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In SomeNameSpace</span><br><span class="line">In Nested</span><br></pre></td></tr></table></figure><h2 id="using的用法："><a href="#using的用法：" class="headerlink" title="using的用法："></a>using的用法：</h2><p><strong>1. using指令：引入命名空间</strong></p><p>这是最常见的用法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Namespace1.SubNameSpace;</span><br></pre></td></tr></table></figure><p><strong>2. using static 指令：指定无需指定类型名称即可访问其静态成员的类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using static System.Math;var = PI; // 直接使用System.Math.PI</span><br></pre></td></tr></table></figure><p><strong>3. 起别名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using Project = PC.MyCompany.Project;</span><br></pre></td></tr></table></figure><p><strong>4. using语句：将实例与代码绑定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using (Font font3 = new Font(&quot;Arial&quot;, 10.0f),</span><br><span class="line">            font4 = new Font(&quot;Arial&quot;, 10.0f))</span><br><span class="line">&#123;</span><br><span class="line">    // Use font3 and font4.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码段结束时，自动调用font3和font4的Dispose方法，释放实例。</p><h1 id="C-预处理器指令"><a href="#C-预处理器指令" class="headerlink" title="C# 预处理器指令"></a>C# 预处理器指令</h1><p>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。</p><p>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。</p><p>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。</p><h2 id="C-预处理器指令列表"><a href="#C-预处理器指令列表" class="headerlink" title="C# 预处理器指令列表"></a>C# 预处理器指令列表</h2><p>下表列出了 C# 中可用的预处理器指令：</p><table><thead><tr><th>预处理器指令</th><th>描述</th></tr></thead><tbody><tr><td>#define</td><td>它用于定义一系列成为符号的字符。</td></tr><tr><td>#undef</td><td>它用于取消定义符号。</td></tr><tr><td>#if</td><td>它用于测试符号是否为真。</td></tr><tr><td>#else</td><td>它用于创建复合条件指令，与 #if 一起使用。</td></tr><tr><td>#elif</td><td>它用于创建复合条件指令。</td></tr><tr><td>#endif</td><td>指定一个条件指令的结束。</td></tr><tr><td>#line</td><td>它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。</td></tr><tr><td>#error</td><td>它允许从代码的指定位置生成一个错误。</td></tr><tr><td>#warning</td><td>它允许从代码的指定位置生成一级警告。</td></tr><tr><td>#region</td><td>它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。</td></tr><tr><td>#endregion</td><td>它标识着 #region 块的结束。</td></tr></tbody></table><h2 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h2><p>#define预处理器指令创建符号常量。</p><p>#define允许您定义一个符号，这样，通过使用符号作为传递给#if指令的表达式，表达式将返回true。它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define symbol</span><br></pre></td></tr></table></figure><p>下面的程序说明了这点： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define PI</span><br><span class="line">using System;</span><br><span class="line">namespace PreprocessorDApp1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            #if (PI)</span><br><span class="line">                Console.WriteLine(&quot;PI is defined&quot;);</span><br><span class="line">            #else</span><br><span class="line">                Console.WriteLine(&quot;PI is not defined&quot;);</span><br><span class="line">            #endif</span><br><span class="line">                Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI is defined</span><br></pre></td></tr></table></figure><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>您可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。</p><p>条件指令的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#if symbol [operator symbol]...</span><br></pre></td></tr></table></figure><p>其中，<em>symbol</em> 是要测试的符号名称。您也可以使用 true 和 false，或在符号前放置否定运算符。</p><p>常见运算符有：</p><ul><li>== (等于)</li><li>!= (不等于)</li><li>&amp;&amp; (与)</li><li>|| (或)</li></ul><p>您也可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 <strong>#if</strong> 指令开始的条件指令，必须显示地以一个 <strong>#endif</strong> 指令终止。</p><p>下面的程序演示了条件指令的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define DEBUG</span><br><span class="line">#define VC_V10</span><br><span class="line">using System;</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      #if (DEBUG &amp;&amp; !VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;DEBUG is defined&quot;);</span><br><span class="line">      #elif (!DEBUG &amp;&amp; VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;VC_V10 is defined&quot;);</span><br><span class="line">      #elif (DEBUG &amp;&amp; VC_V10)</span><br><span class="line">         Console.WriteLine(&quot;DEBUG and VC_V10 are defined&quot;);</span><br><span class="line">      #else</span><br><span class="line">         Console.WriteLine(&quot;DEBUG and VC_V10 are not defined&quot;);</span><br><span class="line">      #endif</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG and VC_V10 are defined</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-命名空间（Namespace）&quot;&gt;&lt;a href=&quot;#C-命名空间（Namespace）&quot; class=&quot;headerlink&quot; title=&quot;C# 命名空间（Namespace）&quot;&gt;&lt;/a&gt;C# 命名空间（Namespace）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(13)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-13/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-13/</id>
    <published>2018-06-26T05:59:45.000Z</published>
    <updated>2018-06-26T06:37:47.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C# 继承"></a>C# 继承</h1><p>继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。</p><p>当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的<strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。</p><p>继承的思想实现了 <strong>属于（IS-A）</strong> 关系。例如，哺乳动物 <strong>属于（IS-A）</strong> 动物，狗 <strong>属于（IS-A）</strong> 哺乳动物，因此狗 <strong>属于（IS-A）</strong> 动物。</p><h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><p>一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。</p><p>C# 中创建派生类的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;acess-specifier&gt; class &lt;base_class&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">class &lt;derived_class&gt; : &lt;base_class&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设，有一个基类 Shape，它的派生类是 Rectangle： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace InheritanceApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      public void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      protected int width;</span><br><span class="line">      protected int height;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 派生类</span><br><span class="line">   class Rectangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public int getArea()</span><br><span class="line">      &#123; </span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle Rect = new Rectangle();</span><br><span class="line"></span><br><span class="line">         Rect.setWidth(5);</span><br><span class="line">         Rect.setHeight(7);</span><br><span class="line"></span><br><span class="line">         // 打印对象的面积</span><br><span class="line">         Console.WriteLine(&quot;总面积： &#123;0&#125;&quot;,  Rect.getArea());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总面积： 35</span><br></pre></td></tr></table></figure><h2 id="基类的初始化"><a href="#基类的初始化" class="headerlink" title="基类的初始化"></a>基类的初始化</h2><p>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。</p><p>下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Rectangle</span><br><span class="line">   &#123;</span><br><span class="line">      // 成员变量</span><br><span class="line">      protected double length;</span><br><span class="line">      protected double width;</span><br><span class="line">      public Rectangle(double l, double w)</span><br><span class="line">      &#123;</span><br><span class="line">         length = l;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public double GetArea()</span><br><span class="line">      &#123;</span><br><span class="line">         return length * width;</span><br><span class="line">      &#125;</span><br><span class="line">      public void Display()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">         Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;//end class Rectangle  </span><br><span class="line">   class Tabletop : Rectangle</span><br><span class="line">   &#123;</span><br><span class="line">      private double cost;</span><br><span class="line">      public Tabletop(double l, double w) : base(l, w)</span><br><span class="line">      &#123; &#125;</span><br><span class="line">      public double GetCost()</span><br><span class="line">      &#123;</span><br><span class="line">         double cost;</span><br><span class="line">         cost = GetArea() * 70;</span><br><span class="line">         return cost;</span><br><span class="line">      &#125;</span><br><span class="line">      public void Display()</span><br><span class="line">      &#123;</span><br><span class="line">         base.Display();</span><br><span class="line">         Console.WriteLine(&quot;成本： &#123;0&#125;&quot;, GetCost());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class ExecuteRectangle</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Tabletop t = new Tabletop(4.5, 7.5);</span><br><span class="line">         t.Display();</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 7.5</span><br><span class="line">面积： 33.75</span><br><span class="line">成本： 2362.5</span><br></pre></td></tr></table></figure><h2 id="C-多重继承"><a href="#C-多重继承" class="headerlink" title="C# 多重继承"></a>C# 多重继承</h2><p>多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。</p><p><strong>C# 不支持多重继承</strong>。但是，您可以使用接口来实现多重继承。下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace InheritanceApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      public void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      protected int width;</span><br><span class="line">      protected int height;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 基类 PaintCost</span><br><span class="line">   public interface PaintCost </span><br><span class="line">   &#123;</span><br><span class="line">      int getCost(int area);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   // 派生类</span><br><span class="line">   class Rectangle : Shape, PaintCost</span><br><span class="line">   &#123;</span><br><span class="line">      public int getArea()</span><br><span class="line">      &#123;</span><br><span class="line">         return (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">      public int getCost(int area)</span><br><span class="line">      &#123;</span><br><span class="line">         return area * 70;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle Rect = new Rectangle();</span><br><span class="line">         int area;</span><br><span class="line">         Rect.setWidth(5);</span><br><span class="line">         Rect.setHeight(7);</span><br><span class="line">         area = Rect.getArea();</span><br><span class="line">         // 打印对象的面积</span><br><span class="line">         Console.WriteLine(&quot;总面积： &#123;0&#125;&quot;,  Rect.getArea());</span><br><span class="line">         Console.WriteLine(&quot;油漆总成本： $&#123;0&#125;&quot; , Rect.getCost(area));</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总面积： 35</span><br><span class="line">油漆总成本： $2450</span><br></pre></td></tr></table></figure><h1 id="C-多态性"><a href="#C-多态性" class="headerlink" title="C# 多态性"></a>C# 多态性</h1><p><strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。</p><p>多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，函数的响应是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p><h2 id="静态多态性"><a href="#静态多态性" class="headerlink" title="静态多态性"></a>静态多态性</h2><p>在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p><ul><li>函数重载</li><li>运算符重载</li></ul><p>运算符重载将在下一章节讨论，接下来我们将讨论函数重载</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。</p><p>下面的实例演示了几个相同的函数 <strong>print()</strong>，用于打印不同的数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Printdata</span><br><span class="line">   &#123;</span><br><span class="line">      void print(int i)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing int: &#123;0&#125;&quot;, i );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      void print(double f)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing float: &#123;0&#125;&quot; , f);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      void print(string s)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Printing string: &#123;0&#125;&quot;, s);</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Printdata p = new Printdata();</span><br><span class="line">         // 调用 print 来打印整数</span><br><span class="line">         p.print(5);</span><br><span class="line">         // 调用 print 来打印浮点数</span><br><span class="line">         p.print(500.263);</span><br><span class="line">         // 调用 print 来打印字符串</span><br><span class="line">         p.print(&quot;Hello C++&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Printing int: 5</span><br><span class="line">Printing float: 500.263</span><br><span class="line">Printing string: Hello C++</span><br></pre></td></tr></table></figure><h2 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h2><p>C# 允许您使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><p>请注意，下面是有关抽象类的一些规则：</p><ul><li>您不能创建一个抽象类的实例。</li><li>您不能在一个抽象类外部声明一个抽象方法。</li><li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   abstract class Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public abstract int area();</span><br><span class="line">   &#125;</span><br><span class="line">   class Rectangle:  Shape</span><br><span class="line">   &#123;</span><br><span class="line">      private int length;</span><br><span class="line">      private int width;</span><br><span class="line">      public Rectangle( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         length = a;</span><br><span class="line">         width = b;</span><br><span class="line">      &#125;</span><br><span class="line">      public override int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         Console.WriteLine(&quot;Rectangle 类的面积：&quot;);</span><br><span class="line">         return (width * length); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class RectangleTester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle r = new Rectangle(10, 7);</span><br><span class="line">         double a = r.area();</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;,a);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle 类的面积：</span><br><span class="line">面积： 70</span><br></pre></td></tr></table></figure><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用<strong>虚方法</strong>。虚方法是使用关键字 <strong>virtual</strong> 声明的。虚方法可以在不同的继承类中有不同的实现。对虚方法的调用是在运行时发生的。</p><p>动态多态性是通过 <strong>抽象类</strong> 和 <strong>虚方法</strong> 实现的。</p><p>下面的程序演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace PolymorphismApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Shape </span><br><span class="line">   &#123;</span><br><span class="line">      protected int width, height;</span><br><span class="line">      public Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      public virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;父类的面积：&quot;);</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Rectangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public Rectangle( int a=0, int b=0): base(a, b)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      public override int area ()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Rectangle 类的面积：&quot;);</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Triangle: Shape</span><br><span class="line">   &#123;</span><br><span class="line">      public Triangle(int a = 0, int b = 0): base(a, b)</span><br><span class="line">      &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      public override int area()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Triangle 类的面积：&quot;);</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Caller</span><br><span class="line">   &#123;</span><br><span class="line">      public void CallArea(Shape sh)</span><br><span class="line">      &#123;</span><br><span class="line">         int a;</span><br><span class="line">         a = sh.area();</span><br><span class="line">         Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, a);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Caller c = new Caller();</span><br><span class="line">         Rectangle r = new Rectangle(10, 7);</span><br><span class="line">         Triangle t = new Triangle(10, 5);</span><br><span class="line">         c.CallArea(r);</span><br><span class="line">         c.CallArea(t);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rectangle 类的面积：</span><br><span class="line">面积：70</span><br><span class="line">Triangle 类的面积：</span><br><span class="line">面积：25</span><br></pre></td></tr></table></figure><h1 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C# 运算符重载"></a>C# 运算符重载</h1><p>您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 <strong>operator</strong> 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。</p><p>例如，请看下面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Box operator+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">   Box box = new Box();</span><br><span class="line">   box.length = b.length + c.length;</span><br><span class="line">   box.breadth = b.breadth + c.breadth;</span><br><span class="line">   box.height = b.height + c.height;</span><br><span class="line">   return box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数为用户自定义的类 Box 实现了加法运算符（+）。它把两个 Box 对象的属性相加，并返回相加后的 Box 对象。 </p><h2 id="运算符重载的实现"><a href="#运算符重载的实现" class="headerlink" title="运算符重载的实现"></a>运算符重载的实现</h2><p>下面的程序演示了完整的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorOvlApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Box</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;      // 长度</span><br><span class="line">      private double breadth;     // 宽度</span><br><span class="line">      private double height;      // 高度</span><br><span class="line"></span><br><span class="line">      public double getVolume()</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">         breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">         height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符来把两个 Box 对象相加</span><br><span class="line">      public static Box operator+ (Box b, Box c)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box = new Box();</span><br><span class="line">         box.length = b.length + c.length;</span><br><span class="line">         box.breadth = b.breadth + c.breadth;</span><br><span class="line">         box.height = b.height + c.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Box Box1 = new Box();         // 声明 Box1，类型为 Box</span><br><span class="line">         Box Box2 = new Box();         // 声明 Box2，类型为 Box</span><br><span class="line">         Box Box3 = new Box();         // 声明 Box3，类型为 Box</span><br><span class="line">         double volume = 0.0;          // 体积</span><br><span class="line"></span><br><span class="line">         // Box1 详述</span><br><span class="line">         Box1.setLength(6.0);</span><br><span class="line">         Box1.setBreadth(7.0);</span><br><span class="line">         Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">         // Box2 详述</span><br><span class="line">         Box2.setLength(12.0);</span><br><span class="line">         Box2.setBreadth(13.0);</span><br><span class="line">         Box2.setHeight(10.0);</span><br><span class="line"></span><br><span class="line">         // Box1 的体积</span><br><span class="line">         volume = Box1.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">         // Box2 的体积</span><br><span class="line">         volume = Box2.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">         // 把两个对象相加</span><br><span class="line">         Box3 = Box1 + Box2;</span><br><span class="line"></span><br><span class="line">         // Box3 的体积</span><br><span class="line">         volume = Box3.getVolume();</span><br><span class="line">         Console.WriteLine(&quot;Box3 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br><span class="line">Box3 的体积： 5400</span><br></pre></td></tr></table></figure><h2 id="可重载和不可重载运算符"><a href="#可重载和不可重载运算符" class="headerlink" title="可重载和不可重载运算符"></a>可重载和不可重载运算符</h2><p>下表描述了 C# 中运算符重载的能力：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+, -, !, ~, ++, –</td><td>这些一元运算符只有一个操作数，且可以被重载。</td></tr><tr><td>+, -, *, /, %</td><td>这些二元运算符带有两个操作数，且可以被重载。</td></tr><tr><td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td><td>这些比较运算符可以被重载。</td></tr><tr><td>&amp;&amp;, \</td><td>\</td><td></td><td>这些条件逻辑运算符不能被直接重载。</td></tr><tr><td>+=, -=, *=, /=, %=</td><td>这些赋值运算符不能被重载。</td></tr><tr><td>=, ., ?:, -&gt;, new, is, sizeof, typeof</td><td>这些运算符不能被重载。</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>针对上述讨论，让我们扩展上面的实例，重载更多的运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorOvlApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       private double length;      // 长度</span><br><span class="line">       private double breadth;     // 宽度</span><br><span class="line">       private double height;      // 高度</span><br><span class="line">      </span><br><span class="line">       public double getVolume()</span><br><span class="line">       &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符来把两个 Box 对象相加</span><br><span class="line">      public static Box operator+ (Box b, Box c)</span><br><span class="line">      &#123;</span><br><span class="line">          Box box = new Box();</span><br><span class="line">          box.length = b.length + c.length;</span><br><span class="line">          box.breadth = b.breadth + c.breadth;</span><br><span class="line">          box.height = b.height + c.height;</span><br><span class="line">          return box;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public static bool operator == (Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length == rhs.length &amp;&amp; lhs.height == rhs.height </span><br><span class="line">             &amp;&amp; lhs.breadth == rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public static bool operator !=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length != rhs.length || lhs.height != rhs.height </span><br><span class="line">              || lhs.breadth != rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public static bool operator &lt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &lt; rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &lt; rhs.height &amp;&amp; lhs.breadth &lt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &gt;(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &gt; rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &lt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &lt;= rhs.length &amp;&amp; lhs.height </span><br><span class="line">              &lt;= rhs.height &amp;&amp; lhs.breadth &lt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static bool operator &gt;=(Box lhs, Box rhs)</span><br><span class="line">      &#123;</span><br><span class="line">          bool status = false;</span><br><span class="line">          if (lhs.length &gt;= rhs.length &amp;&amp; lhs.height </span><br><span class="line">             &gt;= rhs.height &amp;&amp; lhs.breadth &gt;= rhs.breadth)</span><br><span class="line">          &#123;</span><br><span class="line">              status = true;</span><br><span class="line">          &#125;</span><br><span class="line">          return status;</span><br><span class="line">      &#125;</span><br><span class="line">      public override string ToString()</span><br><span class="line">      &#123;</span><br><span class="line">          return String.Format(&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;, length, breadth, height);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   class Tester</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">        Box Box1 = new Box();          // 声明 Box1，类型为 Box</span><br><span class="line">        Box Box2 = new Box();          // 声明 Box2，类型为 Box</span><br><span class="line">        Box Box3 = new Box();          // 声明 Box3，类型为 Box</span><br><span class="line">        Box Box4 = new Box();</span><br><span class="line">        double volume = 0.0;   // 体积</span><br><span class="line"></span><br><span class="line">        // Box1 详述</span><br><span class="line">        Box1.setLength(6.0);</span><br><span class="line">        Box1.setBreadth(7.0);</span><br><span class="line">        Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">        // Box2 详述</span><br><span class="line">        Box2.setLength(12.0);</span><br><span class="line">        Box2.setBreadth(13.0);</span><br><span class="line">        Box2.setHeight(10.0);</span><br><span class="line"></span><br><span class="line">       // 使用重载的 ToString() 显示两个盒子</span><br><span class="line">        Console.WriteLine(&quot;Box1： &#123;0&#125;&quot;, Box1.ToString());</span><br><span class="line">        Console.WriteLine(&quot;Box2： &#123;0&#125;&quot;, Box2.ToString());</span><br><span class="line">        </span><br><span class="line">        // Box1 的体积</span><br><span class="line">        volume = Box1.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        // Box2 的体积</span><br><span class="line">        volume = Box2.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        // 把两个对象相加</span><br><span class="line">        Box3 = Box1 + Box2;</span><br><span class="line">        Console.WriteLine(&quot;Box3： &#123;0&#125;&quot;, Box3.ToString());</span><br><span class="line">        // Box3 的体积</span><br><span class="line">        volume = Box3.getVolume();</span><br><span class="line">        Console.WriteLine(&quot;Box3 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line"></span><br><span class="line">        //comparing the boxes</span><br><span class="line">        if (Box1 &gt; Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 大于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不大于 Box2&quot;);</span><br><span class="line">        if (Box1 &lt; Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 小于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不小于 Box2&quot;);</span><br><span class="line">        if (Box1 &gt;= Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 大于等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不大于等于 Box2&quot;);</span><br><span class="line">        if (Box1 &lt;= Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 小于等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 不小于等于 Box2&quot;);</span><br><span class="line">        if (Box1 != Box2)</span><br><span class="line">          Console.WriteLine(&quot;Box1 不等于 Box2&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box1 等于 Box2&quot;);</span><br><span class="line">        Box4 = Box3;</span><br><span class="line">        if (Box3 == Box4)</span><br><span class="line">          Console.WriteLine(&quot;Box3 等于 Box4&quot;);</span><br><span class="line">        else</span><br><span class="line">          Console.WriteLine(&quot;Box3 不等于 Box4&quot;);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Box1： (6, 7, 5)</span><br><span class="line">Box2： (12, 13, 10)</span><br><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br><span class="line">Box3： (18, 20, 15)</span><br><span class="line">Box3 的体积： 5400</span><br><span class="line">Box1 不大于 Box2</span><br><span class="line">Box1 小于 Box2</span><br><span class="line">Box1 不大于等于 Box2</span><br><span class="line">Box1 小于等于 Box2</span><br><span class="line">Box1 不等于 Box2</span><br><span class="line">Box3 等于 Box4</span><br></pre></td></tr></table></figure><h1 id="C-接口（Interface）"><a href="#C-接口（Interface）" class="headerlink" title="C# 接口（Interface）"></a>C# 接口（Interface）</h1><p>接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。</p><p>接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。</p><p>接口使得实现接口的类或结构在形式上保持一致。</p><p>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。</p><h2 id="定义接口-MyInterface-cs"><a href="#定义接口-MyInterface-cs" class="headerlink" title="定义接口: MyInterface.cs"></a>定义接口: MyInterface.cs</h2><p>接口使用 <strong>interface</strong> 关键字声明，它与类的声明类似。接口声明默认是 public 的。下面是一个接口声明的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了接口 IMyInterface。通常接口命令以 I 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然我们可以按照需求设置参数和返回值。</p><p>值得注意的是，该方法并没有具体的实现。</p><h3 id="接下来我们来实现以上接口：InterfaceImplementer-cs"><a href="#接下来我们来实现以上接口：InterfaceImplementer-cs" class="headerlink" title="接下来我们来实现以上接口：InterfaceImplementer.cs"></a>接下来我们来实现以上接口：InterfaceImplementer.cs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    // 接口成员</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterfaceImplementer : IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MethodToImplement()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MethodToImplement() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class InterfaceImplementer : IMyInterface</span><br></pre></td></tr></table></figure><p>继承接口后，我们需要实现接口的方法 MethodToImplement() , 方法名必须与接口定义的方法名一致。</p><h2 id="接口继承-InterfaceInheritance-cs"><a href="#接口继承-InterfaceInheritance-cs" class="headerlink" title="接口继承: InterfaceInheritance.cs"></a>接口继承: InterfaceInheritance.cs</h2><p>以下实例定义了两个接口 IMyInterface 和 IParentInterface。</p><p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。</p><p>以下实例 IMyInterface 继承了 IParentInterface 接口，因此接口实现类必须实现 MethodToImplement() 和 ParentInterfaceMethod() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">interface IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">    void ParentInterfaceMethod();</span><br><span class="line">&#125;</span><br><span class="line">interface IMyInterface:IParentInterface</span><br><span class="line">&#123;</span><br><span class="line">void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line">class InterfaceImplementer:IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">    InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">    iImp.MethodToImplement();</span><br><span class="line">    iImp.ParentInterfaceMethod();;</span><br><span class="line">    &#125;</span><br><span class="line">    public void MethodToImplement()</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;MethodToImplement() called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void ParentInterfaceMethod()</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;ParentInterfaceMethod() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodToImplement() called.</span><br><span class="line">ParentInterfaceMethod() called.</span><br></pre></td></tr></table></figure><p>接口注意的几点：</p><ol><li>接口方法不能用public abstract等修饰。接口内不能有字段变量，构造函数。</li><li>接口内可以定义属性（有get和set的方法）。如string color { get ; set ; }这种。</li><li>实现接口时，必须和接口的格式一致。</li><li>必须实现接口的所有方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-继承&quot;&gt;&lt;a href=&quot;#C-继承&quot; class=&quot;headerlink&quot; title=&quot;C# 继承&quot;&gt;&lt;/a&gt;C# 继承&lt;/h1&gt;&lt;p&gt;继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(12)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-12/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-12/</id>
    <published>2018-06-26T05:29:27.000Z</published>
    <updated>2018-06-26T05:59:48.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类（Class）"><a href="#C-类（Class）" class="headerlink" title="C# 类（Class）"></a>C# 类（Class）</h1><p>当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量成为类的成员。 </p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类的定义是以关键字 <strong>class</strong> 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; class  class_name </span><br><span class="line">&#123;</span><br><span class="line">    // member variables</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    // member methods</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list) </span><br><span class="line">    &#123;</span><br><span class="line">        // method body </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>访问标识符 <access specifier=""> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</access></li><li>数据类型 <data type=""> 指定了变量的类型，返回类型 <return type=""> 指定了返回的方法返回的数据类型。</return></data></li><li>如果要访问类的成员，你要使用点（.）运算符。</li><li>点运算符链接了对象的名称和成员的名称。</li></ul><p>下面的实例说明了目前为止所讨论的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace BoxApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       public double length;   // 长度</span><br><span class="line">       public double breadth;  // 宽度</span><br><span class="line">       public double height;   // 高度</span><br><span class="line">    &#125;</span><br><span class="line">    class Boxtester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = new Box();        // 声明 Box1，类型为 Box</span><br><span class="line">            Box Box2 = new Box();        // 声明 Box2，类型为 Box</span><br><span class="line">            double volume = 0.0;         // 体积</span><br><span class="line"></span><br><span class="line">            // Box1 详述</span><br><span class="line">            Box1.height = 5.0;</span><br><span class="line">            Box1.length = 6.0;</span><br><span class="line">            Box1.breadth = 7.0;</span><br><span class="line"></span><br><span class="line">            // Box2 详述</span><br><span class="line">            Box2.height = 10.0;</span><br><span class="line">            Box2.length = 12.0;</span><br><span class="line">            Box2.breadth = 13.0;</span><br><span class="line">           </span><br><span class="line">            // Box1 的体积</span><br><span class="line">            volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class="line">            Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot;,  volume);</span><br><span class="line"></span><br><span class="line">            // Box2 的体积</span><br><span class="line">            volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class="line">            Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br></pre></td></tr></table></figure><h2 id="成员函数和封装"><a href="#成员函数和封装" class="headerlink" title="成员函数和封装"></a>成员函数和封装</h2><p>类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。</p><p>成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。</p><p>让我们使用上面的概念来设置和获取一个类中不同的类成员的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace BoxApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">       private double length;   // 长度</span><br><span class="line">       private double breadth;  // 宽度</span><br><span class="line">       private double height;   // 高度</span><br><span class="line">       public void setLength( double len )</span><br><span class="line">       &#123;</span><br><span class="line">            length = len;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setBreadth( double bre )</span><br><span class="line">       &#123;</span><br><span class="line">            breadth = bre;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setHeight( double hei )</span><br><span class="line">       &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">       &#125;</span><br><span class="line">       public double getVolume()</span><br><span class="line">       &#123;</span><br><span class="line">           return length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Boxtester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = new Box();        // 声明 Box1，类型为 Box</span><br><span class="line">            Box Box2 = new Box();         // 声明 Box2，类型为 Box</span><br><span class="line">            double volume;                 // 体积</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // Box1 详述</span><br><span class="line">            Box1.setLength(6.0);</span><br><span class="line">            Box1.setBreadth(7.0);</span><br><span class="line">            Box1.setHeight(5.0);</span><br><span class="line"></span><br><span class="line">            // Box2 详述</span><br><span class="line">            Box2.setLength(12.0);</span><br><span class="line">            Box2.setBreadth(13.0);</span><br><span class="line">            Box2.setHeight(10.0);</span><br><span class="line">       </span><br><span class="line">            // Box1 的体积</span><br><span class="line">            volume = Box1.getVolume();</span><br><span class="line">            Console.WriteLine(&quot;Box1 的体积： &#123;0&#125;&quot; ,volume);</span><br><span class="line"></span><br><span class="line">            // Box2 的体积</span><br><span class="line">            volume = Box2.getVolume();</span><br><span class="line">            Console.WriteLine(&quot;Box2 的体积： &#123;0&#125;&quot;, volume);</span><br><span class="line">           </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积： 210</span><br><span class="line">Box2 的体积： 1560</span><br></pre></td></tr></table></figure><h2 id="C-中的构造函数"><a href="#C-中的构造函数" class="headerlink" title="C# 中的构造函数"></a>C# 中的构造函数</h2><p>类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。</p><p>构造函数的名称与类的名称完全相同，它没有任何返回类型。</p><p>下面的实例说明了构造函数的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line();    </span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象已创建</span><br><span class="line">线条的长度： 6</span><br></pre></td></tr></table></figure><p><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。这种技术可以帮助你在创建对象的同时给对象赋初始值，具体请看下面实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line(double len)  // 参数化构造函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建，length = &#123;0&#125;&quot;, len);</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line(10.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength()); </span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength()); </span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象已创建，length = 10</span><br><span class="line">线条的长度： 10</span><br><span class="line">线条的长度： 6</span><br></pre></td></tr></table></figure><h2 id="C-中的析构函数"><a href="#C-中的析构函数" class="headerlink" title="C# 中的析构函数"></a>C# 中的析构函数</h2><p>类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。</p><p>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p><p>下面的实例说明了析构函数的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace LineApplication</span><br><span class="line">&#123;</span><br><span class="line">   class Line</span><br><span class="line">   &#123;</span><br><span class="line">      private double length;   // 线条的长度</span><br><span class="line">      public Line()  // 构造函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已创建&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      ~Line() //析构函数</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;对象已删除&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      public double getLength()</span><br><span class="line">      &#123;</span><br><span class="line">         return length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Line line = new Line();</span><br><span class="line">         // 设置线条长度</span><br><span class="line">         line.setLength(6.0);</span><br><span class="line">         Console.WriteLine(&quot;线条的长度： &#123;0&#125;&quot;, line.getLength());           </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象已创建</span><br><span class="line">线条的长度： 6</span><br><span class="line">对象已删除</span><br></pre></td></tr></table></figure><h2 id="C-类的静态成员"><a href="#C-类的静态成员" class="headerlink" title="C# 类的静态成员"></a>C# 类的静态成员</h2><p>我们可以使用 <strong>static</strong> 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。</p><p>关键字 <strong>static</strong> 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。你也可以在类的定义内部初始化静态变量。</p><p>下面的实例演示了<strong>静态变量</strong>的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StaticVarApplication</span><br><span class="line">&#123;</span><br><span class="line">    class StaticVar</span><br><span class="line">    &#123;</span><br><span class="line">       public static int num;</span><br><span class="line">        public void count()</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        public int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class StaticTester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            StaticVar s1 = new StaticVar();</span><br><span class="line">            StaticVar s2 = new StaticVar();</span><br><span class="line">            s1.count();</span><br><span class="line">            s1.count();</span><br><span class="line">            s1.count();</span><br><span class="line">            s2.count();</span><br><span class="line">            s2.count();</span><br><span class="line">            s2.count();         </span><br><span class="line">            Console.WriteLine(&quot;s1 的变量 num： &#123;0&#125;&quot;, s1.getNum());</span><br><span class="line">            Console.WriteLine(&quot;s2 的变量 num： &#123;0&#125;&quot;, s2.getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 的变量 num： 6</span><br><span class="line">s2 的变量 num： 6</span><br></pre></td></tr></table></figure><p>你也可以把一个<strong>成员函数</strong>声明为 <strong>static</strong>。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。下面的实例演示了<strong>静态函数</strong>的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StaticVarApplication</span><br><span class="line">&#123;</span><br><span class="line">    class StaticVar</span><br><span class="line">    &#123;</span><br><span class="line">       public static int num;</span><br><span class="line">        public void count()</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        public static int getNum()</span><br><span class="line">        &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class StaticTester</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            StaticVar s = new StaticVar();</span><br><span class="line">            s.count();</span><br><span class="line">            s.count();</span><br><span class="line">            s.count();                   </span><br><span class="line">            Console.WriteLine(&quot;变量 num： &#123;0&#125;&quot;, StaticVar.getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 num： 3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-类（Class）&quot;&gt;&lt;a href=&quot;#C-类（Class）&quot; class=&quot;headerlink&quot; title=&quot;C# 类（Class）&quot;&gt;&lt;/a&gt;C# 类（Class）&lt;/h1&gt;&lt;p&gt;当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(11)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-11/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-11/</id>
    <published>2018-06-26T04:24:38.000Z</published>
    <updated>2018-06-26T05:33:30.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-结构体（Struct）"><a href="#C-结构体（Struct）" class="headerlink" title="C# 结构体（Struct）"></a>C# 结构体（Struct）</h1><p>在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<strong>struct</strong> 关键字用于创建结构体。</p><p>结构体是用来代表一个记录。假设您想跟踪图书馆中书的动态。您可能想跟踪每本书的以下属性：</p><ul><li>Title</li><li>Author</li><li>Subject</li><li>Book ID</li></ul><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>为了定义一个结构体，您必须使用 struct 语句。struct 语句为程序定义了一个带有多个成员的新的数据类型。</p><p>例如，您可以按照如下的方式声明 Book 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   public string title;</span><br><span class="line">   public string author;</span><br><span class="line">   public string subject;</span><br><span class="line">   public int book_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的程序演示了结构的用法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">     </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   public string title;</span><br><span class="line">   public string author;</span><br><span class="line">   public string subject;</span><br><span class="line">   public int book_id;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">public class testStructure</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1;        /* 声明 Book1，类型为 Book */</span><br><span class="line">      Books Book2;        /* 声明 Book2，类型为 Book */</span><br><span class="line"></span><br><span class="line">      /* book 1 详述 */</span><br><span class="line">      Book1.title = &quot;C Programming&quot;;</span><br><span class="line">      Book1.author = &quot;Nuha Ali&quot;; </span><br><span class="line">      Book1.subject = &quot;C Programming Tutorial&quot;;</span><br><span class="line">      Book1.book_id = 6495407;</span><br><span class="line"></span><br><span class="line">      /* book 2 详述 */</span><br><span class="line">      Book2.title = &quot;Telecom Billing&quot;;</span><br><span class="line">      Book2.author = &quot;Zara Ali&quot;;</span><br><span class="line">      Book2.subject =  &quot;Telecom Billing Tutorial&quot;;</span><br><span class="line">      Book2.book_id = 6495700;</span><br><span class="line"></span><br><span class="line">      /* 打印 Book1 信息 */</span><br><span class="line">      Console.WriteLine( &quot;Book 1 title : &#123;0&#125;&quot;, Book1.title);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 author : &#123;0&#125;&quot;, Book1.author);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 subject : &#123;0&#125;&quot;, Book1.subject);</span><br><span class="line">      Console.WriteLine(&quot;Book 1 book_id :&#123;0&#125;&quot;, Book1.book_id);</span><br><span class="line"></span><br><span class="line">      /* 打印 Book2 信息 */</span><br><span class="line">      Console.WriteLine(&quot;Book 2 title : &#123;0&#125;&quot;, Book2.title);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 author : &#123;0&#125;&quot;, Book2.author);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 subject : &#123;0&#125;&quot;, Book2.subject);</span><br><span class="line">      Console.WriteLine(&quot;Book 2 book_id : &#123;0&#125;&quot;, Book2.book_id);       </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-结构的特点"><a href="#C-结构的特点" class="headerlink" title="C# 结构的特点"></a>C# 结构的特点</h2><p>您已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：</p><ul><li>结构可带有方法、字段、索引、属性、运算符方法和事件。</li><li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义默认的构造函数。默认的构造函数是自动定义的，且不能被改变。</li><li>与类不同，结构不能继承其他的结构或类。</li><li>结构不能作为其他结构或类的基础结构。</li><li>结构可实现一个或多个接口。</li><li>结构成员不能指定为 abstract、virtual 或 protected。</li><li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li><li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><h2 id="类-vs-结构"><a href="#类-vs-结构" class="headerlink" title="类 vs 结构"></a>类 vs 结构</h2><p>类和结构有以下几个基本的不同点：</p><ul><li>类是引用类型，结构是值类型。</li><li>结构不支持继承。</li><li>结构不能声明默认的构造函数。</li></ul><p>针对上述讨论，让我们重写前面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">     </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   private string title;</span><br><span class="line">   private string author;</span><br><span class="line">   private string subject;</span><br><span class="line">   private int book_id;</span><br><span class="line">   public void getValues(string t, string a, string s, int id)</span><br><span class="line">   &#123;</span><br><span class="line">      title = t;</span><br><span class="line">      author = a;</span><br><span class="line">      subject = s;</span><br><span class="line">      book_id =id; </span><br><span class="line">   &#125;</span><br><span class="line">   public void display()</span><br><span class="line">   &#123;</span><br><span class="line">      Console.WriteLine(&quot;Title : &#123;0&#125;&quot;, title);</span><br><span class="line">      Console.WriteLine(&quot;Author : &#123;0&#125;&quot;, author);</span><br><span class="line">      Console.WriteLine(&quot;Subject : &#123;0&#125;&quot;, subject);</span><br><span class="line">      Console.WriteLine(&quot;Book_id :&#123;0&#125;&quot;, book_id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">public class testStructure</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1 = new Books(); /* 声明 Book1，类型为 Book */</span><br><span class="line">      Books Book2 = new Books(); /* 声明 Book2，类型为 Book */</span><br><span class="line"></span><br><span class="line">      /* book 1 详述 */</span><br><span class="line">      Book1.getValues(&quot;C Programming&quot;,</span><br><span class="line">      &quot;Nuha Ali&quot;, &quot;C Programming Tutorial&quot;,6495407);</span><br><span class="line"></span><br><span class="line">      /* book 2 详述 */</span><br><span class="line">      Book2.getValues(&quot;Telecom Billing&quot;,</span><br><span class="line">      &quot;Zara Ali&quot;, &quot;Telecom Billing Tutorial&quot;, 6495700);</span><br><span class="line"></span><br><span class="line">      /* 打印 Book1 信息 */</span><br><span class="line">      Book1.display();</span><br><span class="line"></span><br><span class="line">      /* 打印 Book2 信息 */</span><br><span class="line">      Book2.display(); </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Title : C Programming</span><br><span class="line">Author : Nuha Ali</span><br><span class="line">Subject : C Programming Tutorial</span><br><span class="line">Book_id : 6495407</span><br><span class="line">Title : Telecom Billing</span><br><span class="line">Author : Zara Ali</span><br><span class="line">Subject : Telecom Billing Tutorial</span><br><span class="line">Book_id : 6495700</span><br></pre></td></tr></table></figure><h1 id="C-枚举（Enum）"><a href="#C-枚举（Enum）" class="headerlink" title="C# 枚举（Enum）"></a>C# 枚举（Enum）</h1><p>枚举是一组命名整型常量。枚举类型是使用 <strong>enum</strong> 关键字声明的。</p><p>C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。</p><h2 id="声明-enum-变量"><a href="#声明-enum-变量" class="headerlink" title="声明 enum 变量"></a>声明 <em>enum</em> 变量</h2><p>声明枚举的一般语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &lt;enum_name&gt;</span><br><span class="line">&#123; </span><br><span class="line">    enumeration list </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><em>enum_name</em> 指定枚举的类型名称。</li><li><em>enumeration list</em> 是一个用逗号分隔的标识符列表。</li></ul><p>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了枚举变量的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace EnumApplication</span><br><span class="line">&#123;</span><br><span class="line">   class EnumProgram</span><br><span class="line">   &#123;</span><br><span class="line">      enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int WeekdayStart = (int)Days.Mon;</span><br><span class="line">         int WeekdayEnd = (int)Days.Fri;</span><br><span class="line">         Console.WriteLine(&quot;Monday: &#123;0&#125;&quot;, WeekdayStart);</span><br><span class="line">         Console.WriteLine(&quot;Friday: &#123;0&#125;&quot;, WeekdayEnd);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monday: 1</span><br><span class="line">Friday: 5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-结构体（Struct）&quot;&gt;&lt;a href=&quot;#C-结构体（Struct）&quot; class=&quot;headerlink&quot; title=&quot;C# 结构体（Struct）&quot;&gt;&lt;/a&gt;C# 结构体（Struct）&lt;/h1&gt;&lt;p&gt;在 C# 中，结构体是值类型数据结构。它使得一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(10)</title>
    <link href="http://yoursite.com/2018/06/26/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-10/"/>
    <id>http://yoursite.com/2018/06/26/C-学习之路-10/</id>
    <published>2018-06-26T03:51:49.000Z</published>
    <updated>2018-06-26T04:24:59.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-数组（Array）"><a href="#C-数组（Array）" class="headerlink" title="C# 数组（Array）"></a>C# 数组（Array）</h1><p>数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p><p>声明数组变量并不是声明 number0、number1、…、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。</p><p>所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/04/arrays.jpg" alt="C# 中的数组"></p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在C#中声明一个数组，您可以使用下面的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datayype[] arrayName;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>datatype用于指定被存储在数组中的元素的类型。</li><li>[]指定数组的秩（维度）。秩指定数组的大小。</li><li>arrayName指定数组的名称。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance;</span><br></pre></td></tr></table></figure><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>声明一个数组不会在内存中初始化数组，当初始化数组变量时，您可以赋值给数组。</p><p>数组是一个引用类型，所以您需要使用 <strong>new</strong>关键字来创建数组的实例。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance = new double[10];</span><br></pre></td></tr></table></figure><h2 id="赋值给数组"><a href="#赋值给数组" class="headerlink" title="赋值给数组"></a>赋值给数组</h2><p>您可以通过使用索引号赋值给一个单独的数组元素，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double[] balance = &#123;2340.0,4523.69,3421.0&#125;</span><br></pre></td></tr></table></figure><p>您也可以创建并且初始化一个数组，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] marks = new int[5] &#123;99,98,92,97,95&#125;;</span><br></pre></td></tr></table></figure><p>在上述情况下，你也可以忽略数组的大小，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] marks = new int[] &#123;99,98,92,97,95&#125;;</span><br></pre></td></tr></table></figure><p>您也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] marks = new int[]  &#123; 99,  98, 92, 97, 95&#125;;</span><br><span class="line">int[] score = marks;</span><br></pre></td></tr></table></figure><p>当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>元素是通过带索引的数组名称来访问的。这是通过把元素的索引位置数组名称后的方括号中来实现的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double salary = balance[9];</span><br></pre></td></tr></table></figure><p>下面是一个实例，使用上面提到的三个概念，即声明、赋值、访问数组： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ArrayApplication</span><br><span class="line">&#123;</span><br><span class="line">    class MyArray</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int[] n = new int[10] ; /*n是一个带有10个整数的数组*/</span><br><span class="line">            int i,j;</span><br><span class="line">            /*初始化数组n中的元素*/</span><br><span class="line">            for(i=0;i&lt;10;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                n[i] = i+100;</span><br><span class="line">            &#125;</span><br><span class="line">            /*输出每个数组元素的值*/</span><br><span class="line">            for(j=0;j&lt;10;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;,j,n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h2 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h2><p>在前面的实例中，我们使用一个 for 循环来访问每个数组元素。您也可以使用一个 <strong>foreach</strong> 语句来遍历数组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ArrayApplication</span><br><span class="line">&#123;</span><br><span class="line">    class MyArray</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">             int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         /* 初始化数组 n 中的元素 */         </span><br><span class="line">         for ( int i = 0; i &lt; 10; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[i] = i + 100;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         /* 输出每个数组元素的值 */</span><br><span class="line">         foreach (int j in n )</span><br><span class="line">         &#123;</span><br><span class="line">            int i = j-100;</span><br><span class="line">            Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;, i, j);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h2 id="C-数组细节"><a href="#C-数组细节" class="headerlink" title="C# 数组细节"></a>C# 数组细节</h2><p>在 C# 中，数组是非常重要的，且需要了解更多的细节。下面列出了 C# 程序员必须清楚的一些与数组相关的重要概念：</p><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-multi-dimensional-arrays.html" target="_blank" rel="noopener">多维数组</a></td><td>C# 支持多维数组。多维数组最简单的形式是二维数组。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-jagged-arrays.html" target="_blank" rel="noopener">交错数组</a></td><td>C# 支持交错数组，即数组的数组。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-passing-arrays-to-functions.html" target="_blank" rel="noopener">传递数组给函数</a></td><td>您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-param-arrays.html" target="_blank" rel="noopener">参数数组</a></td><td>这通常用于传递未知数量的参数给函数。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-array-class.html" target="_blank" rel="noopener">Array 类</a></td><td>在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。</td></tr></tbody></table><h1 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h1><p>在 C# 中，您可以使用字符数组来表示字符串，但是，更常见的做法是使用 <strong>string</strong> 关键字来声明一个字符串变量。string 关键字是 <strong>System.String</strong> 类的别名。 </p><h2 id="创建-String-对象"><a href="#创建-String-对象" class="headerlink" title="创建 String 对象"></a>创建 String 对象</h2><p>您可以使用以下方法之一来创建 string 对象：</p><ul><li>通过给 String 变量指定一个字符串</li><li>通过使用 String 类构造函数</li><li>通过使用字符串串联运算符（ + ）</li><li>通过检索属性或调用一个返回字符串的方法</li><li>通过格式化方法来转换一个值或对象为它的字符串表示形式</li></ul><p>下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //字符串，字符串连接</span><br><span class="line">            string fname, lname;</span><br><span class="line">            fname = &quot;Rowan&quot;;</span><br><span class="line">            lname = &quot;Atkinson&quot;;</span><br><span class="line"></span><br><span class="line">            string fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(&quot;Full Name: &#123;0&#125;&quot;, fullname);</span><br><span class="line"></span><br><span class="line">            //通过使用 string 构造函数</span><br><span class="line">            char[] letters = &#123; &apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;,&apos;o&apos; &#125;;</span><br><span class="line">            string greetings = new string(letters);</span><br><span class="line">            Console.WriteLine(&quot;Greetings: &#123;0&#125;&quot;, greetings);</span><br><span class="line"></span><br><span class="line">            //方法返回字符串</span><br><span class="line">            string[] sarray = &#123; &quot;Hello&quot;, &quot;From&quot;, &quot;Tutorials&quot;, &quot;Point&quot; &#125;;</span><br><span class="line">            string message = String.Join(&quot; &quot;, sarray);</span><br><span class="line">            Console.WriteLine(&quot;Message: &#123;0&#125;&quot;, message);</span><br><span class="line"></span><br><span class="line">            //用于转化值的格式化方法</span><br><span class="line">            DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1);</span><br><span class="line">            string chat = String.Format(&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;, </span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(&quot;Message: &#123;0&#125;&quot;, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Full Name: RowanAtkinson</span><br><span class="line">Greetings: Hello</span><br><span class="line">Message: Hello From Tutorials Point</span><br><span class="line">Message: Message sent at 17:58 on Wednesday, 10 October 2012</span><br></pre></td></tr></table></figure><h2 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h2><p>String 类有以下两个属性：</p><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table><h2 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h2><p>String 类有许多方法用于 string 对象的操作。下面的表格提供了一些最常用的方法：</p><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator, string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table><p>上面的方法列表并不详尽，请访问 MSDN 库，查看完整的方法列表和 String 类构造函数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了上面提到的一些方法：</p><p><strong>比较字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str1 = &quot;This is test&quot;;</span><br><span class="line">         string str2 = &quot;This is text&quot;;</span><br><span class="line"></span><br><span class="line">         if (String.Compare(str1, str2) == 0)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(str1 + &quot; and &quot; + str2 +  &quot; are equal.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(str1 + &quot; and &quot; + str2 + &quot; are not equal.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is test and This is text are not equal.</span><br></pre></td></tr></table></figure><p><strong>字符串包含字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string str = &quot;This is test&quot;;</span><br><span class="line">         if (str.Contains(&quot;test&quot;))</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(&quot;The sequence &apos;test&apos; was found.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The sequence &apos;test&apos; was found.</span><br></pre></td></tr></table></figure><p><strong>获取子字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System; </span><br><span class="line">namespace StringApplication </span><br><span class="line">&#123;</span><br><span class="line">    class StringProg </span><br><span class="line">    &#123; </span><br><span class="line">        static void Main(string[] args) </span><br><span class="line">        &#123; </span><br><span class="line">            string str = &quot;Last night I dreamt of San Pedro&quot;; </span><br><span class="line">            Console.WriteLine(str); </span><br><span class="line">            string substr = str.Substring(23); </span><br><span class="line">            Console.WriteLine(substr); </span><br><span class="line">            Console.ReadKey() ; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last night I dreamt of San Pedro</span><br><span class="line">San Pedro</span><br></pre></td></tr></table></figure><p><strong>连接字符串：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StringApplication</span><br><span class="line">&#123;</span><br><span class="line">   class StringProg</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         string[] starray = new string[]&#123;&quot;Down the way nights are dark&quot;,</span><br><span class="line">         &quot;And the sun shines daily on the mountain top&quot;,</span><br><span class="line">         &quot;I took a trip on a sailing ship&quot;,</span><br><span class="line">         &quot;And when I reached Jamaica&quot;,</span><br><span class="line">         &quot;I made a stop&quot;&#125;;</span><br><span class="line"></span><br><span class="line">         string str = String.Join(&quot;\n&quot;, starray);</span><br><span class="line">         Console.WriteLine(str);</span><br><span class="line">         Console.ReadKey() ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Down the way nights are dark</span><br><span class="line">And the sun shines daily on the mountain top</span><br><span class="line">I took a trip on a sailing ship</span><br><span class="line">And when I reached Jamaica</span><br><span class="line">I made a stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-数组（Array）&quot;&gt;&lt;a href=&quot;#C-数组（Array）&quot; class=&quot;headerlink&quot; title=&quot;C# 数组（Array）&quot;&gt;&lt;/a&gt;C# 数组（Array）&lt;/h1&gt;&lt;p&gt;数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-事件处理</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-事件处理/</id>
    <published>2018-06-26T03:26:35.000Z</published>
    <updated>2018-06-26T03:45:25.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用<code>v-on</code>指令监听DOM事件，并在粗发时运行一些Javascript代码。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter+=1"</span>&gt;</span></span><br><span class="line">        Add 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        The button above has been clicked &#123;&#123;counter&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el : <span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        counter:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><p>然而许多事件处理逻辑会更为复杂，所以直接把Javascript代码写在<code>v-on</code>指令中是不可行的。因此<code>v-on</code>还可以接收一个需要调用的方法名称。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--'greet' 是下面定义的方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span></span><br><span class="line">        Greet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        name:<span class="string">'Vue.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        greet:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">          alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">            <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">            <span class="keyword">if</span> (event) &#123;</span><br><span class="line">                alert(event.target.tagName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。 </p><blockquote><p>2.1.4 新增</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">组件事件</a>上。如果你还没有阅读关于组件的文档，现在大可不必担心。</p><blockquote><p>2.3.0 新增</p></blockquote><p>Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p><p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>记住所有的 <code>keyCode</code> 比较困难，所以 Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><h3 id="自动匹配按键修饰符"><a href="#自动匹配按键修饰符" class="headerlink" title="自动匹配按键修饰符"></a>自动匹配按键修饰符</h3><blockquote><p>2.5.0 新增</p></blockquote><p>你也可直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.page-down</span>=<span class="string">"onPageDown"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，处理函数仅在 <code>$event.key === &#39;PageDown&#39;</code> 时被调用。</p><p>有一些按键 (<code>.esc</code> 以及所有的方向键) 在 IE9 中有不同的 <code>key</code> 值, 如果你想支持 IE9，它们的内置别名应该是首选。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><blockquote><p>2.1.0 新增</p></blockquote><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><blockquote><p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p></blockquote><p>例如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。 </p><h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h3><blockquote><p>2.5.0 新增</p></blockquote><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><blockquote><p>2.2.0 新增</p></blockquote><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p><h2 id="为什么在-HTML-中监听事件"><a href="#为什么在-HTML-中监听事件" class="headerlink" title="为什么在 HTML 中监听事件?"></a>为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事件处理&quot;&gt;&lt;a href=&quot;#事件处理&quot; class=&quot;headerlink&quot; title=&quot;事件处理&quot;&gt;&lt;/a&gt;事件处理&lt;/h1&gt;&lt;h2 id=&quot;监听事件&quot;&gt;&lt;a href=&quot;#监听事件&quot; class=&quot;headerlink&quot; title=&quot;监听事件&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-列表渲染</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-列表渲染/</id>
    <published>2018-06-26T02:18:38.000Z</published>
    <updated>2018-06-26T03:25:52.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="用v-for把一个数组对应为一组元素"><a href="#用v-for把一个数组对应为一组元素" class="headerlink" title="用v-for把一个数组对应为一组元素"></a>用<code>v-for</code>把一个数组对应为一组元素</h2><p>我们用<code>v-for</code>指令根据一组数组的选项列表进行渲染。<code>v-for</code>指令需要使用<code>item in items</code>形式的特殊语法，<code>items</code>是源数据数组并且<code>item</code>是数组元素迭代的别名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        items:[</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·Foo</span><br><span class="line">·Bar</span><br></pre></td></tr></table></figure><p>在<code>v-for</code>块中，我们拥有对父作用域属性的完全访问权限。<code>v-for</code>还支持一个可选的第二个参数为当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123;parentMessage&#125;&#125; - &#123;&#123;index&#125;&#125; - &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        parentMessage:<span class="string">'Parent'</span>,</span><br><span class="line">        items:[</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">·Parent-0-Foo</span><br><span class="line">·Parent-1-Bar</span><br></pre></td></tr></table></figure><p>你也可以用<code>of</code>替代<code>in</code>作为分隔符，因为它是最接近Javascript迭代器的语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一个对象的-v-for"><a href="#一个对象的-v-for" class="headerlink" title="一个对象的 v-for"></a>一个对象的 <code>v-for</code></h2><p>你也可以用<code>v-for</code>通过一个对象的属性来迭代。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        object:&#123;</span><br><span class="line">            firstName:<span class="string">'John'</span>,</span><br><span class="line">            lastName:<span class="string">'Doe'</span>,</span><br><span class="line">            age:<span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">·John</span><br><span class="line">·Doe</span><br><span class="line">·30</span><br></pre></td></tr></table></figure><p>你也可以提供第二个的参数为键名： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstName:John</span><br><span class="line">lastName:Doe</span><br><span class="line">age:30</span><br></pre></td></tr></table></figure><p>第三参数为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.firstName:John</span><br><span class="line">1.lastName:Doe</span><br><span class="line">2.age:30</span><br></pre></td></tr></table></figure><p>在遍历对象时，是按 <code>Object.keys()</code> 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 </p><h2 id="key"><a href="#key" class="headerlink" title="key"></a><code>key</code></h2><p>当Vue.js用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用”就地复用”策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的数据，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似Vue 1.x的<code>track-by=&quot;$index&quot;</code></p><p>这个默认的模式是高效的，但是只适用于<strong>不依赖组件状态或临时DOM状态(例如：表单输入值)的列表渲染输出</strong>。</p><p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要每项提供一个唯一<code>key</code>属性。理想的<code>key</code>值是每项都有的且唯一的id。这个特殊的属性相当于Vue 1.x的<code>track-by</code>,但它的工作方式类似于一个属性，所以你需要用<code>v-bind</code>来绑定动态值(在这里使用简写):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议尽可能在使用<code>v-for</code>时提供<code>key</code>，除非遍历输出的DOM内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>因为它是Vue识别节点的一个通用机制，<code>key</code>并不是<code>v-for</code>特别关联，key还具有其他用途，我们将在后面的指南中看到其他用途。</p><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><p>你打开控制台，然后用前面例子的 <code>items</code> 数组调用变异方法：<code>example1.items.push({ message: &#39;Baz&#39; })</code> 。</p><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：<code>filter()</code>, <code>concat()</code> 和 <code>slice()</code> 。这些不会改变原始数组，但<strong>总是返回一个新数组</strong>。当使用非变异方法时，可以用新数组替换旧数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(function (item) &#123;</span><br><span class="line">  return item.message.match(/Foo/)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>vm.$set</code> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 <code>splice</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="对象更改检测注意事项"><a href="#对象更改检测注意事项" class="headerlink" title="对象更改检测注意事项"></a>对象更改检测注意事项</h2><p>还是由于 JavaScript 的限制，<strong>Vue 不能检测对象属性的添加或删除</strong>： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。例如，对于： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以添加一个新的 <code>age</code> 属性到嵌套的 <code>userProfile</code> 对象： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>vm.$set</code> 实例方法，它只是全局 <code>Vue.set</code> 的别名： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你应该这样做： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">        evenNumbers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number%<span class="number">2</span> === <span class="number">0</span> </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个 method 方法： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    even:<span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段取值范围的-v-for"><a href="#一段取值范围的-v-for" class="headerlink" title="一段取值范围的 v-for"></a>一段取值范围的 <code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h2 id="v-for-on-a-lt-template-gt"><a href="#v-for-on-a-lt-template-gt" class="headerlink" title="v-for on a &lt;template&gt;"></a><code>v-for</code> on a <code>&lt;template&gt;</code></h2><p>类似于<code>v-if</code>，你也可以利用带有<code>v-for</code>的<code>&lt;template&gt;</code>渲染多个元素。比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"></a><code>v-for</code> with <code>v-if</code></h2><p>当它们处于同一节点，<code>v-for</code>的优先级比<code>v-if</code>更高，这意味着<code>v-if</code>将分别重复运行每个<code>v-for</code>循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码只传递了未完成的 todos。 而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>)上。如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一个组件的-v-for"><a href="#一个组件的-v-for" class="headerlink" title="一个组件的 v-for"></a>一个组件的 <code>v-for</code></h2><p>了解组件相关知识，查看 <a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a>。完全可以先跳过它，以后再回来查看。 </p><p>在自定义组件里，你可以像任何普通元素一样用 <code>v-for</code> 。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.0+ 的版本里，当在组件中使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。 </p><p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 <code>props</code> ： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 </p><p>下面是一个简单的 todo list 的完整例子： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"addNewTodo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"new-todo"</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"new-todo"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">"E.g. Feed the cat"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>,&#123;</span><br><span class="line">    template:<span class="string">'&lt;li&gt;&#123;&#123;title&#125;&#125; &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;&lt;/li&gt;'</span>,</span><br><span class="line">    props:[<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        newTodoText:<span class="string">''</span>,</span><br><span class="line">        todos:[</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">1</span>,</span><br><span class="line">            title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">2</span>,</span><br><span class="line">            title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">3</span>,</span><br><span class="line">            title: <span class="string">'Mow the lawn'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        newTodoId:<span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        addNewTodo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">                id:<span class="keyword">this</span>.newTodoId++,</span><br><span class="line">                title:<span class="keyword">this</span>.newTodoText</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表渲染&quot;&gt;&lt;a href=&quot;#列表渲染&quot; class=&quot;headerlink&quot; title=&quot;列表渲染&quot;&gt;&lt;/a&gt;列表渲染&lt;/h1&gt;&lt;h2 id=&quot;用v-for把一个数组对应为一组元素&quot;&gt;&lt;a href=&quot;#用v-for把一个数组对应为一组元素&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-条件渲染</title>
    <link href="http://yoursite.com/2018/06/26/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2018/06/26/Vue的知识点积累-条件渲染/</id>
    <published>2018-06-26T01:57:46.000Z</published>
    <updated>2018-06-26T02:16:46.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if" target="_blank" rel="noopener"><code>v-if</code></a></h2><p>在字符串模板中，比如Handlebars，我们得像这样写一个条件块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handlebars 模板--&gt;</span></span><br><span class="line">&#123;&#123;#if ok&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure><p>在Vue中，我们使用v-if指令实现同样的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">'ok'</span>&gt;</span></span><br><span class="line">    Yes</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    No</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-lt-template-gt-元素上使用v-if条件渲染分组"><a href="#在-lt-template-gt-元素上使用v-if条件渲染分组" class="headerlink" title="在&lt;template&gt;元素上使用v-if条件渲染分组"></a>在<code>&lt;template&gt;</code>元素上使用<code>v-if</code>条件渲染分组</h3><p>因为<code>v-if</code>是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个<code>&lt;template&gt;</code>元素当做不可见的包裹元素，并在上面使用<code>v-if</code>。最终的渲染结果包含<code>&lt;template&gt;</code>元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        Title</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Paragraph1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Paragraph2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h3><p>你可以使用<code>v-else</code>指令来表示<code>v-if</code>的”else块”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-else</code>元素必须紧跟在带有<code>v-if</code>或者<code>v-else-if</code>的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h3><p>2.1.0 新增 </p><p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。 </p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。 </p><p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> 属性即可： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> 属性。 </p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a><code>v-if</code> 与 <code>v-for</code> 一起使用</h2><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;条件渲染&quot;&gt;&lt;a href=&quot;#条件渲染&quot; class=&quot;headerlink&quot; title=&quot;条件渲染&quot;&gt;&lt;/a&gt;条件渲染&lt;/h1&gt;&lt;h2 id=&quot;v-if&quot;&gt;&lt;a href=&quot;#v-if&quot; class=&quot;headerlink&quot; title=&quot;v-if&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(9)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-9/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-9/</id>
    <published>2018-06-25T03:44:09.000Z</published>
    <updated>2018-06-26T01:57:59.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h1><h2 id="C-单问号-与-双问号"><a href="#C-单问号-与-双问号" class="headerlink" title="C# 单问号 ? 与 双问号 ??"></a>C# 单问号 ? 与 双问号 ??</h2><p>? : 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? i = 3 </span><br><span class="line">等同于</span><br><span class="line">Nullable&lt;int&gt; i = new Nullable&lt;int&gt;(3);</span><br><span class="line"></span><br><span class="line">int i; //默认值0</span><br><span class="line">int? ii; //默认值null</span><br></pre></td></tr></table></figure><p>?? : 双问号 可用于判断一个变量在为 null 时返回一个指定的值。</p><p>接下来我们详细说明。</p><h2 id="C-可空类型（Nullable）-1"><a href="#C-可空类型（Nullable）-1" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h2><p>C# 提供了一个特殊的数据类型，<strong>nullable</strong> 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p>例如，Nullable&lt; Int32 &gt;，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable&lt; bool &gt; 变量可以被赋值为 true 或 false 或 null。</p><p>在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。</p><p>声明一个 <strong>nullable</strong> 类型（可空类型）的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; data_type&gt; ? &lt;variable_name&gt; = null;</span><br></pre></td></tr></table></figure><p>下面的实例演示了可空数据类型的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int? num1 = null;</span><br><span class="line">         int? num2 = 45;</span><br><span class="line">         double? num3 = new double?();</span><br><span class="line">         double? num4 = 3.14157;</span><br><span class="line">         </span><br><span class="line">         bool? boolval = new bool?();</span><br><span class="line"></span><br><span class="line">         // 显示值</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;显示可空类型的值： &#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;, </span><br><span class="line">                            num1, num2, num3, num4);</span><br><span class="line">         Console.WriteLine(&quot;一个可空的布尔值： &#123;0&#125;&quot;, boolval);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">显示可空类型的值： , 45,  , 3.14157</span><br><span class="line">一个可空的布尔值：</span><br></pre></td></tr></table></figure><h2 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h2><p>Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。</p><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   &#123;</span><br><span class="line">         </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         </span><br><span class="line">         double? num1 = null;</span><br><span class="line">         double? num2 = 3.14157;</span><br><span class="line">         double num3;</span><br><span class="line">         num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34</span><br><span class="line">         Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);</span><br><span class="line">         num3 = num2 ?? 5.34;</span><br><span class="line">         Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num3 的值： 5.34</span><br><span class="line">num3 的值： 3.14157</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-可空类型（Nullable）&quot;&gt;&lt;a href=&quot;#C-可空类型（Nullable）&quot; class=&quot;headerlink&quot; title=&quot;C# 可空类型（Nullable）&quot;&gt;&lt;/a&gt;C# 可空类型（Nullable）&lt;/h1&gt;&lt;h2 id=&quot;C-单问号-与
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(8)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-8/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-8/</id>
    <published>2018-06-25T03:18:12.000Z</published>
    <updated>2018-06-25T03:42:49.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-方法"><a href="#C-方法" class="headerlink" title="C# 方法"></a>C# 方法</h1><p>一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个C#程序至少有一个带有Main方法的类。</p><p>要使用一个方法，您需要：</p><ul><li>定义方法</li><li>调用方法</li></ul><h2 id="C-中定义方法"><a href="#C-中定义方法" class="headerlink" title="C# 中定义方法"></a>C# 中定义方法</h2><p>当定义一个方法时，从根本上说是在声明它的结构的元素。在C#中，定义方法的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是方法的各个元素：</p><ul><li><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</li><li><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</li><li><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</li><li><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</li><li><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的代码片段显示一个函数 <em>FindMax</em>，它接受两个整数值，并返回两个中的较大值。它有 public 访问修饰符，所以它可以使用类的实例从类的外部进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class NumberManipulator</span><br><span class="line">&#123;</span><br><span class="line">   public int FindMax(int num1, int num2)</span><br><span class="line">   &#123;</span><br><span class="line">      /* 局部变量声明 */</span><br><span class="line">      int result;</span><br><span class="line"></span><br><span class="line">      if (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      else</span><br><span class="line">         result = num2;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h2><p>您可以使用方法名调用方法。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public int FindMax(int num1, int num2)</span><br><span class="line">      &#123;</span><br><span class="line">         /* 局部变量声明 */</span><br><span class="line">         int result;</span><br><span class="line"></span><br><span class="line">         if (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">         else</span><br><span class="line">            result = num2;</span><br><span class="line"></span><br><span class="line">         return result;</span><br><span class="line">      &#125;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         int b = 200;</span><br><span class="line">         int ret;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line"></span><br><span class="line">         //调用 FindMax 方法</span><br><span class="line">         ret = n.FindMax(a, b);</span><br><span class="line">         Console.WriteLine(&quot;最大值是： &#123;0&#125;&quot;, ret );</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是： 200</span><br></pre></td></tr></table></figure><p>您也可以使用类的实例从另一个类中调用其他类的公有方法。例如，方法 <em>FindMax</em>属于 <em>NumberManipulator</em> 类，您可以从另一个类 <em>Test</em> 中调用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public int FindMax(int num1, int num2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量声明 */</span><br><span class="line">            int result;</span><br><span class="line"></span><br><span class="line">            if (num1 &gt; num2)</span><br><span class="line">                result = num1;</span><br><span class="line">            else</span><br><span class="line">                result = num2;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量定义 */</span><br><span class="line">            int a = 100;</span><br><span class="line">            int b = 200;</span><br><span class="line">            int ret;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            //调用 FindMax 方法</span><br><span class="line">            ret = n.FindMax(a, b);</span><br><span class="line">            Console.WriteLine(&quot;最大值是： &#123;0&#125;&quot;, ret );</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是： 200</span><br></pre></td></tr></table></figure><h2 id="递归方法调用"><a href="#递归方法调用" class="headerlink" title="递归方法调用"></a>递归方法调用</h2><p>一个方法可以自我调用。这就是所谓的 <strong>递归</strong>。下面的实例使用递归函数计算一个数的阶乘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public int factorial(int num)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 局部变量定义 */</span><br><span class="line">            int result;</span><br><span class="line"></span><br><span class="line">            if (num == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                result = factorial(num - 1) * num;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            //调用 factorial 方法</span><br><span class="line">            Console.WriteLine(&quot;6 的阶乘是： &#123;0&#125;&quot;, n.factorial(6));</span><br><span class="line">            Console.WriteLine(&quot;7 的阶乘是： &#123;0&#125;&quot;, n.factorial(7));</span><br><span class="line">            Console.WriteLine(&quot;8 的阶乘是： &#123;0&#125;&quot;, n.factorial(8));</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 的阶乘是： 720</span><br><span class="line">7 的阶乘是： 5040</span><br><span class="line">8 的阶乘是： 40320</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当调用带有参数的方法时，您需要向方法传递参数。在 C# 中，有三种向方法传递参数的方式：</p><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td>值参数</td><td>这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td></tr><tr><td>引用参数</td><td>这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td></tr><tr><td>输出参数</td><td>这种方式可以返回多个值。</td></tr></tbody></table><h2 id="按值传递参数"><a href="#按值传递参数" class="headerlink" title="按值传递参数"></a>按值传递参数</h2><p>这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。下面的实例演示了这个概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public void swap(int x, int y)</span><br><span class="line">      &#123;</span><br><span class="line">         int temp;</span><br><span class="line">         </span><br><span class="line">         temp = x; /* 保存 x 的值 */</span><br><span class="line">         x = y;    /* 把 y 赋值给 x */</span><br><span class="line">         y = temp; /* 把 temp 赋值给 y */</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         int b = 200;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在交换之前，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.WriteLine(&quot;在交换之前，b 的值： &#123;0&#125;&quot;, b);</span><br><span class="line">         </span><br><span class="line">         /* 调用函数来交换值 */</span><br><span class="line">         n.swap(a, b);</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在交换之后，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.WriteLine(&quot;在交换之后，b 的值： &#123;0&#125;&quot;, b);</span><br><span class="line">         </span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：100</span><br><span class="line">在交换之后，b 的值：200</span><br></pre></td></tr></table></figure><p>结果表明，即使在函数内改变了值，值也没有发生任何的变化。</p><h2 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h2><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculationApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public void  swap(ref int a,ref int b)</span><br><span class="line">        &#123;</span><br><span class="line">            int temp ;</span><br><span class="line">            temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b =temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            </span><br><span class="line">            int a = 100;</span><br><span class="line">            int b = 200;</span><br><span class="line">            Console.WriteLine(&quot;交换前：a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            /*数据交换*/</span><br><span class="line">            n.swap(ref a,ref b);</span><br><span class="line">            Console.WriteLine(&quot;交换后：a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h2 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h2><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">&#123;</span><br><span class="line">   class NumberManipulator</span><br><span class="line">   &#123;</span><br><span class="line">      public void getValue(out int x )</span><br><span class="line">      &#123;</span><br><span class="line">         int temp = 5;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = new NumberManipulator();</span><br><span class="line">         /* 局部变量定义 */</span><br><span class="line">         int a = 100;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         </span><br><span class="line">         /* 调用函数来获取值 */</span><br><span class="line">         n.getValue(out a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CalculationApplication</span><br><span class="line">&#123;</span><br><span class="line">    class NumberManipulator</span><br><span class="line">    &#123;</span><br><span class="line">        public void  getVal(out int a,out int b)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Please enter the first number:&quot;);</span><br><span class="line">            a = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(&quot;Please enter the second number:&quot;);</span><br><span class="line">            b = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            NumberManipulator n = new NumberManipulator();</span><br><span class="line">            </span><br><span class="line">            int a;</span><br><span class="line">            int b ;</span><br><span class="line">            /*数据输入*/</span><br><span class="line">            n.getVal(out a,out b);</span><br><span class="line">            Console.WriteLine(&quot;enter number : a=&#123;0&#125;,b=&#123;1&#125;&quot;,a,b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please enter the first number:</span><br><span class="line">7</span><br><span class="line">Please enter the second number:</span><br><span class="line">8</span><br><span class="line">enter number : a=7,b=8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-方法&quot;&gt;&lt;a href=&quot;#C-方法&quot; class=&quot;headerlink&quot; title=&quot;C# 方法&quot;&gt;&lt;/a&gt;C# 方法&lt;/h1&gt;&lt;p&gt;一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个C#程序至少有一个带有Main方法的类。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(7)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-7/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-7/</id>
    <published>2018-06-25T02:59:21.000Z</published>
    <updated>2018-06-25T03:17:24.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h1><p><strong>封装</strong>被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中“。在面向对象设计方法论中，封装是为了防止对实现细节的访问。</p><p>抽象和封装是面向对象设计的相关性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</p><p>C#封装根据具体的需要，设置使用者的访问权限，并通过<strong>访问修饰符</strong>来实现。</p><p>一个<strong>访问修饰符</strong>定义了一个类成员的范围和可见性。C#支持的访问修饰符如下所示：</p><ul><li>public：所有对象都可以访问；</li><li>private：对象本身在对象内部可以访问；</li><li>protected：只有该类对象及其子类对象可以访问；</li><li>internal：同一个程序集的对象可以访问；</li><li>protected internal：访问限于当前程序集或派生自包含类的类型</li></ul><h2 id="Public-访问修饰符"><a href="#Public-访问修饰符" class="headerlink" title="Public 访问修饰符"></a>Public 访问修饰符</h2><p>Public访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</p><p>下面的实例说明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        //成员变量</span><br><span class="line">        public double length;</span><br><span class="line">        public double width;</span><br><span class="line"></span><br><span class="line">        public double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;// Rectangle 结束</span><br><span class="line"></span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.length = 4.5;</span><br><span class="line">            r.width = 3.5;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 3.5</span><br><span class="line">面积： 15.75</span><br></pre></td></tr></table></figure><p>在上面的实例中，成员变量 length 和 width 被声明为 <strong>public</strong>，所以它们可以被函数 Main() 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><p>成员函数 <em>Display()</em> 和 <em>GetArea()</em> 可以直接访问这些变量。</p><p>成员函数 <em>Display()</em> 也被声明为 <strong>public</strong>，所以它也能被 <em>Main()</em> 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><h2 id="Private-访问修饰符"><a href="#Private-访问修饰符" class="headerlink" title="Private 访问修饰符"></a>Private 访问修饰符</h2><p>Private访问修饰符允许一个类将成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</p><p>下面实例说明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        //成员变量</span><br><span class="line">        private double length;</span><br><span class="line">        private double width;</span><br><span class="line"></span><br><span class="line">        public void Acceptdetails()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入长度：&quot;);</span><br><span class="line">            length = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(&quot;请输入宽度：&quot;);</span><br><span class="line">            width = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">        &#125;</span><br><span class="line">        public double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//end class Rectangle    </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.Acceptdetails();</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入长度：</span><br><span class="line">4.4</span><br><span class="line">请输入宽度：</span><br><span class="line">3.3</span><br><span class="line">长度： 4.4</span><br><span class="line">宽度： 3.3</span><br><span class="line">面积： 14.52</span><br></pre></td></tr></table></figure><p>在上面的实例中，成员变量 length 和 width 被声明为 <strong>private</strong>，所以它们不能被函数 Main() 访问。</p><p>成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 可以访问这些变量。</p><p>由于成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 被声明为 <strong>public</strong>，所以它们可以被 <em>Main()</em> 使用 Rectangle 类的实例 <strong>r</strong> 访问。</p><h2 id="Internal-访问修饰符"><a href="#Internal-访问修饰符" class="headerlink" title="Internal 访问修饰符"></a>Internal 访问修饰符</h2><p>Internal访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有internal访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。</p><p>下面的实例说明了这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace Rectanglepplication</span><br><span class="line">&#123;</span><br><span class="line">     //成员变量</span><br><span class="line">        internal double length;</span><br><span class="line">        internal double width;</span><br><span class="line">        </span><br><span class="line">        double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length * width;</span><br><span class="line">        &#125;</span><br><span class="line">       public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);</span><br><span class="line">            Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);</span><br><span class="line">            Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//end class Rectangle    </span><br><span class="line">    class ExecuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.length = 4.5;</span><br><span class="line">            r.width = 3.5;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 3.5</span><br><span class="line">面积： 15.75</span><br></pre></td></tr></table></figure><p>在上面的实例中，请注意成员函数 <em>GetArea()</em> 声明的时候不带有任何访问修饰符。如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 <strong>private</strong>。</p><h2 id="Protected-Internal-访问修饰符"><a href="#Protected-Internal-访问修饰符" class="headerlink" title="Protected Internal 访问修饰符"></a>Protected Internal 访问修饰符</h2><p>Protected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-封装&quot;&gt;&lt;a href=&quot;#C-封装&quot; class=&quot;headerlink&quot; title=&quot;C#封装&quot;&gt;&lt;/a&gt;C#封装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中“。在面向对象设计方法论中，封
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(6)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-6/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-6/</id>
    <published>2018-06-25T02:50:34.000Z</published>
    <updated>2018-06-25T02:58:56.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C# 判断"></a>C# 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><p>下面是大多数编程语言中典型的判断结构的一般形式：<img src="http://www.runoob.com/wp-content/uploads/2015/12/if.png" alt="C# 中的判断语句"></p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C# 提供了以下类型的判断语句。点击链接查看每个语句的细节。</p><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-if.html" target="_blank" rel="noopener">if 语句</a></td><td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-if-else.html" target="_blank" rel="noopener">if…else 语句</a></td><td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-if.html" target="_blank" rel="noopener">嵌套 if 语句</a></td><td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-switch.html" target="_blank" rel="noopener">switch 语句</a></td><td>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-switch.html" target="_blank" rel="noopener">嵌套 switch 语句</a></td><td>您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="? : 运算符"></a>? : 运算符</h2><p>我们已经在前面的章节中讲解了 <strong>条件运算符 ? :</strong>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure><p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p><p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C# 循环"></a>C# 循环</h1><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p><p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：<img src="http://www.runoob.com/wp-content/uploads/2014/04/loop_architecture.jpg" alt="循环结构"></p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>C# 提供了以下几种循环类型。点击链接查看每个类型的细节。</p><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-while-loop.html" target="_blank" rel="noopener">while 循环</a></td><td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-for-loop.html" target="_blank" rel="noopener">for/foreach 循环</a></td><td>多次执行一个语句序列，简化管理循环变量的代码。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-do-while-loop.html" target="_blank" rel="noopener">do…while 循环</a></td><td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-nested-loops.html" target="_blank" rel="noopener">嵌套循环</a></td><td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr></tbody></table><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p><p>C# 提供了下列的控制语句。点击链接查看每个语句的细节。</p><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/csharp/csharp-break-statement.html" target="_blank" rel="noopener">break 语句</a></td><td>终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr><tr><td><a href="http://www.runoob.com/csharp/csharp-continue-statement.html" target="_blank" rel="noopener">continue 语句</a></td><td>引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr></tbody></table><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace Loops</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            for (; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hey! I am Trapped&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，程序员偏向于使用 for(;;) 结构来表示一个无限循环。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-判断&quot;&gt;&lt;a href=&quot;#C-判断&quot; class=&quot;headerlink&quot; title=&quot;C# 判断&quot;&gt;&lt;/a&gt;C# 判断&lt;/h1&gt;&lt;p&gt;判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(5)</title>
    <link href="http://yoursite.com/2018/06/25/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-5/"/>
    <id>http://yoursite.com/2018/06/25/C-学习之路-5/</id>
    <published>2018-06-25T02:32:35.000Z</published>
    <updated>2018-06-25T02:50:01.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C# 运算符"></a>C# 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p>本教程将逐一讲解算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符及其他运算符。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表显示了 C# 支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>把两个操作数相加</td><td>A + B 将得到 30</td></tr><tr><td>-</td><td>从第一个操作数中减去第二个操作数</td><td>A - B 将得到 -10</td></tr><tr><td>*</td><td>把两个操作数相乘</td><td>A * B 将得到 200</td></tr><tr><td>/</td><td>分子除以分母</td><td>B / A 将得到 2</td></tr><tr><td>%</td><td>取模运算符，整除后的余数</td><td>B % A 将得到 0</td></tr><tr><td>++</td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 11</td></tr><tr><td>–</td><td>自减运算符，整数值减少 1</td><td>A– 将得到 9</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的算术运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 21;</span><br><span class="line">            int b = 10;</span><br><span class="line">            int c;</span><br><span class="line"></span><br><span class="line">            c = a + b;</span><br><span class="line">            Console.WriteLine(&quot;Line 1 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a - b;</span><br><span class="line">            Console.WriteLine(&quot;Line 2 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a * b;</span><br><span class="line">            Console.WriteLine(&quot;Line 3 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a / b;</span><br><span class="line">            Console.WriteLine(&quot;Line 4 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            c = a % b;</span><br><span class="line">            Console.WriteLine(&quot;Line 5 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            // ++a 先进行自增运算再赋值</span><br><span class="line">            c = ++a;</span><br><span class="line">            Console.WriteLine(&quot;Line 6 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            // 此时 a 的值为 22</span><br><span class="line">            // --a 先进行自减运算再赋值</span><br><span class="line">            c = --a;</span><br><span class="line">            Console.WriteLine(&quot;Line 7 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - c 的值是 31</span><br><span class="line">Line 2 - c 的值是 11</span><br><span class="line">Line 3 - c 的值是 210</span><br><span class="line">Line 4 - c 的值是 2</span><br><span class="line">Line 5 - c 的值是 1</span><br><span class="line">Line 6 - c 的值是 22</span><br><span class="line">Line 7 - c 的值是 21</span><br></pre></td></tr></table></figure><ul><li><strong>c = a++</strong>: 先将 a 赋值给 c，再对 a 进行自增运算。</li><li><strong>c = ++a</strong>: 先将 a 进行自增运算，再将 a 赋值给 c 。</li><li><strong>c = a–</strong>: 先将 a 赋值给 c，再对 a 进行自减运算。</li><li><strong>c = –a</strong>: 先将 a 进行自减运算，再将 a 赋值给 c 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 1;</span><br><span class="line">            int b;</span><br><span class="line"></span><br><span class="line">            // a++ 先赋值再进行自增运算</span><br><span class="line">            b = a++;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // ++a 先进行自增运算再赋值</span><br><span class="line">            a = 1; // 重新初始化 a</span><br><span class="line">            b = ++a;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // a-- 先赋值再进行自减运算</span><br><span class="line">            a = 1;  // 重新初始化 a</span><br><span class="line">            b= a--;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            // --a 先进行自减运算再赋值</span><br><span class="line">            a = 1;  // 重新初始化 a</span><br><span class="line">            b= --a;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;&quot;, a);</span><br><span class="line">            Console.WriteLine(&quot;b = &#123;0&#125;&quot;, b);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = 1</span><br><span class="line">a = 2</span><br><span class="line">b = 2</span><br><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">a = 0</span><br><span class="line">b = 0</span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表显示了 C# 支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(A == B) 不为真。</td></tr><tr><td>!=</td><td>检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(A != B) 为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td>(A &gt; B) 不为真。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td>(A &lt; B) 为真。</td></tr><tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td>(A &gt;= B) 不为真。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td>(A &lt;= B) 为真。</td></tr></tbody></table><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的关系运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">  static void Main(string[] args)</span><br><span class="line">  &#123;</span><br><span class="line">      int a = 21;</span><br><span class="line">      int b = 10;</span><br><span class="line">      </span><br><span class="line">      if (a == b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 1 - a 等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 1 - a 不等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (a &lt; b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 2 - a 小于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 2 - a 不小于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (a &gt; b)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 3 - a 大于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(&quot;Line 3 - a 不大于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      /* 改变 a 和 b 的值 */</span><br><span class="line">      a = 5;</span><br><span class="line">      b = 20;</span><br><span class="line">      if (a &lt;= b)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Line 4 - a 小于或等于 b&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (b &gt;= a)</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Line 5 - b 大于或等于 a&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - a 不等于 b</span><br><span class="line">Line 2 - a 不小于 b</span><br><span class="line">Line 3 - a 大于 b</span><br><span class="line">Line 4 - a 小于或等于 b</span><br><span class="line">Line 5 - b 大于或等于 a</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表显示了 C# 支持的所有逻辑运算符。假设变量 <strong>A</strong> 为布尔值 true，变量 <strong>B</strong> 为布尔值 false，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr><tr><td>\</td><td>\</td><td></td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A \</td><td>\</td><td>B) 为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr></tbody></table><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的逻辑运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            bool a = true;</span><br><span class="line">            bool b = true;</span><br><span class="line">           </span><br><span class="line">            if (a &amp;&amp; b)</span><br><span class="line">            &#123;</span><br><span class="line">               Console.WriteLine(&quot;Line 1 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (a || b)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 2 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /* 改变 a 和 b 的值 */</span><br><span class="line">            a = false;</span><br><span class="line">            b = true;</span><br><span class="line">            if (a &amp;&amp; b)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 3 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 3 - 条件不为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!(a &amp;&amp; b))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Line 4 - 条件为真&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - 条件为真</span><br><span class="line">Line 2 - 条件为真</span><br><span class="line">Line 3 - 条件不为真</span><br><span class="line">Line 4 - 条件为真</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p \</th><th>q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><p>A = 0011 1100</p><p>B = 0000 1101</p><p>-—————-</p><p>A&amp;B = 0000 1100</p><p>A|B = 0011 1101</p><p>A^B = 0011 0001</p><p>~A  = 1100 0011</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>\</td><td></td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A \</td><td>B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的位运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 60;               /* 60 = 0011 1100 */  </span><br><span class="line">            int b = 13;               /* 13 = 0000 1101 */</span><br><span class="line">            int c = 0;           </span><br><span class="line"></span><br><span class="line">             c = a &amp; b;           /* 12 = 0000 1100 */ </span><br><span class="line">             Console.WriteLine(&quot;Line 1 - c 的值是 &#123;0&#125;&quot;, c );</span><br><span class="line"></span><br><span class="line">             c = a | b;           /* 61 = 0011 1101 */</span><br><span class="line">             Console.WriteLine(&quot;Line 2 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a ^ b;           /* 49 = 0011 0001 */</span><br><span class="line">             Console.WriteLine(&quot;Line 3 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = ~a;               /*-61 = 1100 0011 */</span><br><span class="line">             Console.WriteLine(&quot;Line 4 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a &lt;&lt; 2;     /* 240 = 1111 0000 */</span><br><span class="line">             Console.WriteLine(&quot;Line 5 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">             c = a &gt;&gt; 2;     /* 15 = 0000 1111 */</span><br><span class="line">             Console.WriteLine(&quot;Line 6 - c 的值是 &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - c 的值是 12</span><br><span class="line">Line 2 - c 的值是 61</span><br><span class="line">Line 3 - c 的值是 49</span><br><span class="line">Line 4 - c 的值是 -61</span><br><span class="line">Line 5 - c 的值是 240</span><br><span class="line">Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了 C# 支持的赋值运算符：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C <em>= A 相当于 C = C </em> A</td></tr><tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td>%=</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %= A 相当于 C = C % A</td></tr><tr><td>&lt;&lt;=</td><td>左移且赋值运算符</td><td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;=</td><td>右移且赋值运算符</td><td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与且赋值运算符</td><td>C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td>^=</td><td>按位异或且赋值运算符</td><td>C ^= 2 等同于 C = C ^ 2</td></tr><tr><td>\</td><td>=</td><td>按位或且赋值运算符</td><td>C \</td><td>= 2 等同于 C = C \</td><td>2</td></tr></tbody></table><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C# 中所有可用的赋值运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int a = 21;</span><br><span class="line">            int c;</span><br><span class="line"></span><br><span class="line">            c = a;</span><br><span class="line">            Console.WriteLine(&quot;Line 1 - =  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c += a;</span><br><span class="line">            Console.WriteLine(&quot;Line 2 - += c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c -= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 3 - -=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c *= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 4 - *=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c /= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 5 - /=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c = 200;</span><br><span class="line">            c %= a;</span><br><span class="line">            Console.WriteLine(&quot;Line 6 - %=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &lt;&lt;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 7 - &lt;&lt;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &gt;&gt;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 8 - &gt;&gt;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c &amp;= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 9 - &amp;=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c ^= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 10 - ^=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line"></span><br><span class="line">            c |= 2;</span><br><span class="line">            Console.WriteLine(&quot;Line 11 - |=  c 的值 = &#123;0&#125;&quot;, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - =     c 的值 = 21</span><br><span class="line">Line 2 - +=    c 的值 = 42</span><br><span class="line">Line 3 - -=    c 的值 = 21</span><br><span class="line">Line 4 - *=    c 的值 = 441</span><br><span class="line">Line 5 - /=    c 的值 = 21</span><br><span class="line">Line 6 - %=    c 的值 = 11</span><br><span class="line">Line 7 - &lt;&lt;=    c 的值 = 44</span><br><span class="line">Line 8 - &gt;&gt;=    c 的值 = 11</span><br><span class="line">Line 9 - &amp;=    c 的值 = 2</span><br><span class="line">Line 10 - ^=    c 的值 = 0</span><br><span class="line">Line 11 - |=    c 的值 = 2</span><br></pre></td></tr></table></figure><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>下表列出了 C# 支持的其他一些重要的运算符，包括 <strong>sizeof</strong>、<strong>typeof</strong> 和 <strong>? :</strong>。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回数据类型的大小。</td><td>sizeof(int)，将返回 4.</td></tr><tr><td>typeof()</td><td>返回 class 的类型。</td><td>typeof(StreamReader);</td></tr><tr><td>&amp;</td><td>返回变量的地址。</td><td>&a; 将得到变量的实际地址。</td></tr><tr><td>*</td><td>变量的指针。</td><td>*a; 将指向一个变量。</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader;</td></tr></tbody></table><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         </span><br><span class="line">         /* sizeof 运算符的实例 */</span><br><span class="line">         Console.WriteLine(&quot;int 的大小是 &#123;0&#125;&quot;, sizeof(int));</span><br><span class="line">         Console.WriteLine(&quot;short 的大小是 &#123;0&#125;&quot;, sizeof(short));</span><br><span class="line">         Console.WriteLine(&quot;double 的大小是 &#123;0&#125;&quot;, sizeof(double));</span><br><span class="line">         </span><br><span class="line">         /* 三元运算符符的实例 */</span><br><span class="line">         int a, b;</span><br><span class="line">         a = 10;</span><br><span class="line">         b = (a == 1) ? 20 : 30;</span><br><span class="line">         Console.WriteLine(&quot;b 的值是 &#123;0&#125;&quot;, b);</span><br><span class="line"></span><br><span class="line">         b = (a == 10) ? 20 : 30;</span><br><span class="line">         Console.WriteLine(&quot;b 的值是 &#123;0&#125;&quot;, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int 的大小是 4</span><br><span class="line">short 的大小是 2</span><br><span class="line">double 的大小是 8</span><br><span class="line">b 的值是 30</span><br><span class="line">b 的值是 20</span><br></pre></td></tr></table></figure><h2 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C# 中的运算符优先级"></a>C# 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p><p>例如 x = 7 + 3 <em> 2，在这里，x 被赋值为 13，而不是 20，因为运算符 </em> 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* / %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr><tr><td>相等</td><td>== !=</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>\</td><td></td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>\</td><td>\</td><td></td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= \</td><td>=</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace OperatorsAppl</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         int a = 20;</span><br><span class="line">         int b = 10;</span><br><span class="line">         int c = 15;</span><br><span class="line">         int d = 5;</span><br><span class="line">         int e;</span><br><span class="line">         e = (a + b) * c / d;     // ( 30 * 15 ) / 5</span><br><span class="line">         Console.WriteLine(&quot;(a + b) * c / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = ((a + b) * c) / d;   // (30 * 15 ) / 5</span><br><span class="line">         Console.WriteLine(&quot;((a + b) * c) / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = (a + b) * (c / d);   // (30) * (15/5)</span><br><span class="line">         Console.WriteLine(&quot;(a + b) * (c / d) 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line"></span><br><span class="line">         e = a + (b * c) / d;    //  20 + (150/5)</span><br><span class="line">         Console.WriteLine(&quot;a + (b * c) / d 的值是 &#123;0&#125;&quot;, e);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) * c / d 的值是 90</span><br><span class="line">((a + b) * c) / d 的值是 90</span><br><span class="line">(a + b) * (c / d) 的值是 90</span><br><span class="line">a + (b * c) / d 的值是 50</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-运算符&quot;&gt;&lt;a href=&quot;#C-运算符&quot; class=&quot;headerlink&quot; title=&quot;C# 运算符&quot;&gt;&lt;/a&gt;C# 运算符&lt;/h1&gt;&lt;p&gt;运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-Class与Style绑定</title>
    <link href="http://yoursite.com/2018/06/23/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/06/23/Vue的知识点积累-Class与Style绑定/</id>
    <published>2018-06-23T10:06:29.000Z</published>
    <updated>2018-06-23T10:11:13.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 </p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-HTML-Class" target="_blank" rel="noopener">绑定 HTML Class</a></h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">对象语法</a></h3><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据属性 <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">truthiness</a>。</p><p>你可以在对象中传入更多属性来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class 属性共存。当有如下模板:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code>的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">数组语法</a></h3><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1" target="_blank" rel="noopener">[1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A" target="_blank" rel="noopener">用在组件上</a></h3><blockquote><p>这个章节假设你已经对 <a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue 组件</a>有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p></blockquote><p>当在一个自定义组件上使用 <code>class</code> 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。</p><p>例如，如果你声明了这个组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在使用它的时候添加一些 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">class</span>=<span class="string">"baz boo"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 将被渲染为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于带数据绑定 class 也同样适用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 为 truthy<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1" target="_blank" rel="noopener">[1]</a> 时，HTML 将被渲染成为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar active"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F" target="_blank" rel="noopener">绑定内联样式</a></h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95-1" target="_blank" rel="noopener">对象语法</a></h3><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95-1" target="_blank" rel="noopener">数组语法</a></h3><p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80" target="_blank" rel="noopener">自动添加前缀</a></h3><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a><a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%A4%9A%E9%87%8D%E5%80%BC" target="_blank" rel="noopener">多重值</a></h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><p><strong>译者注</strong><br>[1] truthy 不是 <code>true</code>，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN</a> 的解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;p&gt;操作元素的 class 列表
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(4)</title>
    <link href="http://yoursite.com/2018/06/23/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-4/"/>
    <id>http://yoursite.com/2018/06/23/C-学习之路-4/</id>
    <published>2018-06-23T08:33:35.000Z</published>
    <updated>2018-06-23T09:01:29.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C# 变量"></a>C# 变量</h1><p>一个变量只不过是一个供程序操作的存储区的名字。在 C# 中，每个变量都有一个特定的类型，类型决定了变量的内存大小和布局。范围内的值可以存储在内存中，可以对变量进行一系列操作。</p><p>我们已经讨论了各种数据类型。C# 中提供的基本的值类型大致可以分为以下几类：</p><table><thead><tr><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>整数类型</td><td>sbyte、byte、short、ushort、int、uint、long、ulong 和 char</td></tr><tr><td>浮点型</td><td>float 和 double</td></tr><tr><td>十进制类型</td><td>decimal</td></tr><tr><td>布尔类型</td><td>true 或 false 值，指定的值</td></tr><tr><td>空类型</td><td>可为空值的数据类型</td></tr></tbody></table><p>C# 允许定义其他值类型的变量，比如 <strong>enum</strong>，也允许定义引用类型变量，比如 <strong>class</strong>。这些我们将在以后的章节中进行讨论。在本章节中，我们只研究基本变量类型。</p><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C# 中的变量定义"></a>C# 中的变量定义</h2><p>C# 中变量定义的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;data_type&gt; &lt;variable_list&gt;;</span><br></pre></td></tr></table></figure><p>在这里，data_type 必须是一个有效的 C# 数据类型，可以是 char、int、float、double 或其他用户自定义的数据类型。variable_list 可以由一个或多个用逗号分隔的标识符名称组成。</p><p>一些有效的变量定义如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i, j, k;</span><br><span class="line">char c, ch;</span><br><span class="line">float f, salary;</span><br><span class="line">double d;</span><br></pre></td></tr></table></figure><p>您可以在变量定义时进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 100;</span><br></pre></td></tr></table></figure><h2 id="C-中的变量初始化"><a href="#C-中的变量初始化" class="headerlink" title="C# 中的变量初始化"></a>C# 中的变量初始化</h2><p>变量通过在等号后跟一个常量表达式进行初始化（赋值）。初始化的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name = value;</span><br></pre></td></tr></table></figure><p>变量可以在声明时被初始化（指定一个初始值）。初始化由一个等号后跟一个常量表达式组成，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;data_type&gt; &lt;variable_name&gt; = value;</span><br></pre></td></tr></table></figure><p>一些实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int d = 3, f = 5;    /* 初始化 d 和 f. */</span><br><span class="line">byte z = 22;         /* 初始化 z. */</span><br><span class="line">double pi = 3.14159; /* 声明 pi 的近似值 */</span><br><span class="line">char x = &apos;x&apos;;        /* 变量 x 的值为 &apos;x&apos; */</span><br></pre></td></tr></table></figure><p>正确地初始化变量是一个良好的编程习惯，否则有时程序会产生意想不到的结果。</p><p>请看下面的实例，使用了各种类型的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namespace VariableDefinition</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            short a;</span><br><span class="line">            int b ;</span><br><span class="line">            double c;</span><br><span class="line"></span><br><span class="line">            /* 实际初始化 */</span><br><span class="line">            a = 10;</span><br><span class="line">            b = 20;</span><br><span class="line">            c = a + b;</span><br><span class="line">            Console.WriteLine(&quot;a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;&quot;, a, b, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10, b = 20, c = 30</span><br></pre></td></tr></table></figure><h2 id="接受来自用户的值"><a href="#接受来自用户的值" class="headerlink" title="接受来自用户的值"></a>接受来自用户的值</h2><p>System</p><p> 命名空间中的 </p><p>Console</p><p> 类提供了一个函数 </p><p>ReadLine()</p><p>，用于接收来自用户的输入，并把它存储到一个变量中。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">num = Convert.ToInt32(Console.ReadLine());</span><br></pre></td></tr></table></figure><p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p><h2 id="C-中的-Lvalues-和-Rvalues"><a href="#C-中的-Lvalues-和-Rvalues" class="headerlink" title="C# 中的 Lvalues 和 Rvalues"></a>C# 中的 Lvalues 和 Rvalues</h2><p>C# 中的两种表达式：</p><ol><li><strong>lvalue</strong>：lvalue 表达式可以出现在赋值语句的左边或右边。</li><li><strong>rvalue</strong>：rvalue 表达式可以出现在赋值语句的右边，不能出现在赋值语句的左边。</li></ol><p>变量是 lvalue 的，所以可以出现在赋值语句的左边。数值是 rvalue 的，因此不能被赋值，不能出现在赋值语句的左边。下面是一个有效的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int g = 20;</span><br></pre></td></tr></table></figure><p>下面是一个无效的语句，会产生编译时错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 = 20;</span><br></pre></td></tr></table></figure><h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C# 常量"></a>C# 常量</h1><p>常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。</p><p>常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。</p><p>整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。</p><p>这里有一些整数常量的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">212         /* 合法 */</span><br><span class="line">215u        /* 合法 */</span><br><span class="line">0xFeeL      /* 合法 */</span><br><span class="line">078         /* 非法：8 不是一个八进制数字 */</span><br><span class="line">032UU       /* 非法：不能重复后缀 */</span><br></pre></td></tr></table></figure><p>以下是各种类型的整数常量的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">85         /* 十进制 */</span><br><span class="line">0213       /* 八进制 */</span><br><span class="line">0x4b       /* 十六进制 */</span><br><span class="line">30         /* int */</span><br><span class="line">30u        /* 无符号 int */</span><br><span class="line">30l        /* long */</span><br><span class="line">30ul       /* 无符号 long */</span><br></pre></td></tr></table></figure><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p><p>这里有一些浮点常量的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.14159       /* 合法 */</span><br><span class="line">314159E-5L    /* 合法 */</span><br><span class="line">510E          /* 非法：不完全指数 */</span><br><span class="line">210f          /* 非法：没有小数或指数 */</span><br><span class="line">.e55          /* 非法：缺少整数或小数 */</span><br></pre></td></tr></table></figure><p>使用小数形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。</p><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>字符常量是括在单引号里，例如，’x’，且可存储在一个简单的字符类型变量中。一个字符常量可以是一个普通字符（例如 ‘x’）、一个转义序列（例如 ‘\t’）或者一个通用字符（例如 ‘\u02C0’）。</p><p>在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（\n）或制表符 tab（\t）。在这里，列出一些转义序列码：</p><table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>\ 字符</td></tr><tr><td>\’</td><td>‘ 字符</td></tr><tr><td>\”</td><td>“ 字符</td></tr><tr><td>\?</td><td>? 字符</td></tr><tr><td>\a</td><td>Alert 或 bell</td></tr><tr><td>\b</td><td>退格键（Backspace）</td></tr><tr><td>\f</td><td>换页符（Form feed）</td></tr><tr><td>\n</td><td>换行符（Newline）</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符 tab</td></tr><tr><td>\v</td><td>垂直制表符 tab</td></tr><tr><td>\ooo</td><td>一到三位的八进制数</td></tr><tr><td>\xhh . . .</td><td>一个或多个数字的十六进制数</td></tr></tbody></table><p>以下是一些转义序列字符的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace EscapeChar</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Hello\tWorld\n\n&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符常量是括在双引号 “” 里，或者是括在 @”” 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符</p><p>使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。</p><p>这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string a = &quot;hello, world&quot;;                  // hello, world</span><br><span class="line">string b = @&quot;hello, world&quot;;               // hello, world</span><br><span class="line">string c = &quot;hello \t world&quot;;               // hello     world</span><br><span class="line">string d = @&quot;hello \t world&quot;;               // hello \t world</span><br><span class="line">string e = &quot;Joe said \&quot;Hello\&quot; to me&quot;;      // Joe said &quot;Hello&quot; to me</span><br><span class="line">string f = @&quot;Joe said &quot;&quot;Hello&quot;&quot; to me&quot;;   // Joe said &quot;Hello&quot; to me</span><br><span class="line">string g = &quot;\\\\server\\share\\file.txt&quot;;   // \\server\share\file.txt</span><br><span class="line">string h = @&quot;\\server\share\file.txt&quot;;      // \\server\share\file.txt</span><br><span class="line">string i = &quot;one\r\ntwo\r\nthree&quot;;</span><br><span class="line">string j = @&quot;one</span><br><span class="line">two</span><br><span class="line">three&quot;;</span><br></pre></td></tr></table></figure><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>常量是使用 <strong>const</strong> 关键字来定义的 。定义一个常量的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &lt;data_type&gt; &lt;constant_name&gt; = value;</span><br></pre></td></tr></table></figure><p>下面的代码演示了如何在程序中定义和使用常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace DeclaringConstants</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            const double pi = 3.14159; // 常量声明</span><br><span class="line">            double r;</span><br><span class="line">            Console.WriteLine(&quot;Enter Radius: &quot;);</span><br><span class="line">            r = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">            double areaCircle = pi * r * r;</span><br><span class="line">            Console.WriteLine(&quot;Radius: &#123;0&#125;, Area: &#123;1&#125;&quot;, r, areaCircle);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter Radius: </span><br><span class="line">3</span><br><span class="line">Radius: 3, Area: 28.27431</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-变量&quot;&gt;&lt;a href=&quot;#C-变量&quot; class=&quot;headerlink&quot; title=&quot;C# 变量&quot;&gt;&lt;/a&gt;C# 变量&lt;/h1&gt;&lt;p&gt;一个变量只不过是一个供程序操作的存储区的名字。在 C# 中，每个变量都有一个特定的类型，类型决定了变量的内存大小和布局。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(3)</title>
    <link href="http://yoursite.com/2018/06/23/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-3/"/>
    <id>http://yoursite.com/2018/06/23/C-学习之路-3/</id>
    <published>2018-06-23T07:47:45.000Z</published>
    <updated>2018-06-23T08:33:04.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C#基本语法"></a>C#基本语法</h1><p>C# 是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种相互交互的对象组成。相同种类的对象通常具有相同的类型，或者说，是在相同的 class 中。</p><p>例如，以 Rectangle（矩形）对象为例。它具有 length 和 width 属性。根据设计，它可能需要接受这些属性值、计算面积和显示细节。</p><p>让我们来看看一个 Rectangle（矩形）类的实现，并借此讨论 C# 的基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace RectangleApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Rectangle</span><br><span class="line">    &#123;</span><br><span class="line">        //成员变量</span><br><span class="line">        double length;</span><br><span class="line">        double width;</span><br><span class="line">        public void Acceptdetails()</span><br><span class="line">        &#123;</span><br><span class="line">            length = 4.5;</span><br><span class="line">            width = 3.5;</span><br><span class="line">        &#125;</span><br><span class="line">        public double GetArea()</span><br><span class="line">        &#123;</span><br><span class="line">            return length*width;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Display()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Length:&#123;0&#125;&quot;,length);</span><br><span class="line">            Console.WriteLine(&quot;Width:&#123;0&#125;&quot;,width);</span><br><span class="line">            Console.WriteLine(&quot;Area:&#123;0&#125;&quot;,GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ExcuteRectangle</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = new Rectangle();</span><br><span class="line">            r.Acceptdetails();</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Length: 4.5</span><br><span class="line">Width: 3.5</span><br><span class="line">Area: 15.75</span><br></pre></td></tr></table></figure><h2 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h2><p>在任何 C# 程序中的第一条语句都是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br></pre></td></tr></table></figure><p><strong>using</strong> 关键字用于在程序中包含命名空间。一个程序可以包含多个 using 语句。</p><h2 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a><em>class</em> 关键字</h2><p><strong>class</strong> 关键字用于声明一个类。</p><h2 id="C-中的注释"><a href="#C-中的注释" class="headerlink" title="C# 中的注释"></a>C# 中的注释</h2><p>注释是用于解释代码。编译器会忽略注释的条目。在 C# 程序中，多行注释以 /<em> 开始，并以字符 </em>/ 终止，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* This program demonstrates</span><br><span class="line">The basic syntax of C# programming </span><br><span class="line">Language */</span><br></pre></td></tr></table></figure><p>单行注释是用 ‘//‘ 符号表示。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;//end class Rectangle</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>变量是类的属性或数据成员，用于存储数据。在上面的程序中，<em>Rectangle</em> 类有两个成员变量，名为 <em>length</em> 和 <em>width</em>。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>函数是一系列执行指定任务的语句。类的成员函数是在类内声明的。我们举例的类 Rectangle 包含了三个成员函数： <em>AcceptDetails</em>、<em>GetArea</em> 和 <em>Display</em>。</p><h2 id="实例化一个类"><a href="#实例化一个类" class="headerlink" title="实例化一个类"></a>实例化一个类</h2><p>在上面的程序中，类 <em>ExecuteRectangle</em> 是一个包含 <em>Main()</em> 方法和实例化 <em>Rectangle</em> 类的类。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是用来识别类、变量、函数或任何其它用户定义的项目。在 C# 中，类的命名必须遵循如下基本规则：</p><ul><li>标识符必须以字母、下划线或 @ 开头，后面可以跟一系列的字母、数字（ 0 - 9 ）、下划线（ _ ）、@。</li><li>标识符中的第一个字符不能是数字。</li><li>标识符必须不包含任何嵌入的空格或符号，比如 ? - +! # % ^ &amp; * ( ) [ ] { } . ; : “ ‘ / \。</li><li>标识符不能是 C# 关键字。除非它们有一个 @ 前缀。 例如，@if 是有效的标识符，但 if 不是，因为 if 是关键字。</li><li>标识符必须区分大小写。大写字母和小写字母被认为是不同的字母。</li><li>不能与C#的类库名称相同。</li></ul><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C# 关键字"></a>C# 关键字</h2><p>关键字是 C# 编译器预定义的保留字。这些关键字不能用作标识符，但是，如果您想使用这些关键字作为标识符，可以在关键字前面加上 @ 字符作为前缀。</p><p>在 C# 中，有些关键字在代码的上下文中有特殊的意义，如 get 和 set，这些被称为上下文关键字（contextual keywords）。</p><p>下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）：</p><table><thead><tr><th><strong>保留关键字</strong></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>as</td><td>base</td><td>bool</td><td>break</td><td>byte</td><td>case</td></tr><tr><td>catch</td><td>char</td><td>checked</td><td>class</td><td>const</td><td>continue</td><td>decimal</td></tr><tr><td>default</td><td>delegate</td><td>do</td><td>double</td><td>else</td><td>enum</td><td>event</td></tr><tr><td>explicit</td><td>extern</td><td>false</td><td>finally</td><td>fixed</td><td>float</td><td>for</td></tr><tr><td>foreach</td><td>goto</td><td>if</td><td>implicit</td><td>in</td><td>in (generic modifier)</td><td>int</td></tr><tr><td>interface</td><td>internal</td><td>is</td><td>lock</td><td>long</td><td>namespace</td><td>new</td></tr><tr><td>null</td><td>object</td><td>operator</td><td>out</td><td>out (generic modifier)</td><td>override</td><td>params</td></tr><tr><td>private</td><td>protected</td><td>public</td><td>readonly</td><td>ref</td><td>return</td><td>sbyte</td></tr><tr><td>sealed</td><td>short</td><td>sizeof</td><td>stackalloc</td><td>static</td><td>string</td><td>struct</td></tr><tr><td>switch</td><td>this</td><td>throw</td><td>true</td><td>try</td><td>typeof</td><td>uint</td></tr><tr><td>ulong</td><td>unchecked</td><td>unsafe</td><td>ushort</td><td>using</td><td>virtual</td><td>void</td></tr><tr><td>volatile</td><td>while</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>上下文关键字</strong></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>add</td><td>alias</td><td>ascending</td><td>descending</td><td>dynamic</td><td>from</td><td>get</td></tr><tr><td>global</td><td>group</td><td>into</td><td>join</td><td>let</td><td>orderby</td><td>partial (type)</td></tr><tr><td>partial (method)</td><td>remove</td><td>select</td><td>set</td><td></td><td></td></tr></tbody></table><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C# 数据类型"></a>C# 数据类型</h1><p>在 C# 中，变量分为以下几种类型：</p><ul><li>值类型（Value types）</li><li>引用类型（Reference types）</li><li>指针类型（Pointer types）</li></ul><h2 id="值类型（Value-types）"><a href="#值类型（Value-types）" class="headerlink" title="值类型（Value types）"></a>值类型（Value types）</h2><p>值类型变量可以直接分配给一个值。它们是从类 <strong>System.ValueType</strong> 中派生的。</p><p>值类型直接包含数据。比如 <strong>int、char、float</strong>，它们分别存储数字、字符、浮点数。当您声明一个 <strong>int</strong> 类型时，系统分配内存来存储值。</p><p>下表列出了 C# 2010 中可用的值类型：</p><table><thead><tr><th>类型</th><th>描述</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>bool</td><td>布尔值</td><td>True 或 False</td><td>False</td></tr><tr><td>byte</td><td>8 位无符号整数</td><td>0 到 255</td><td>0</td></tr><tr><td>char</td><td>16 位 Unicode 字符</td><td>U +0000 到 U +ffff</td><td>‘\0’</td></tr><tr><td>decimal</td><td>128 位精确的十进制值，28-29 有效位数</td><td>(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td><td>0.0M</td></tr><tr><td>double</td><td>64 位双精度浮点型</td><td>(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td><td>0.0D</td></tr><tr><td>float</td><td>32 位单精度浮点型</td><td>-3.4 x 1038 到 + 3.4 x 1038</td><td>0.0F</td></tr><tr><td>int</td><td>32 位有符号整数类型</td><td>-2,147,483,648 到 2,147,483,647</td><td>0</td></tr><tr><td>long</td><td>64 位有符号整数类型</td><td>-923,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>0L</td></tr><tr><td>sbyte</td><td>8 位有符号整数类型</td><td>-128 到 127</td><td>0</td></tr><tr><td>short</td><td>16 位有符号整数类型</td><td>-32,768 到 32,767</td><td>0</td></tr><tr><td>uint</td><td>32 位无符号整数类型</td><td>0 到 4,294,967,295</td><td>0</td></tr><tr><td>ulong</td><td>64 位无符号整数类型</td><td>0 到 18,446,744,073,709,551,615</td><td>0</td></tr><tr><td>ushort</td><td>16 位无符号整数类型</td><td>0 到 65,535</td><td>0</td></tr></tbody></table><p>如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 <strong>sizeof</strong> 方法。表达式 <em>sizeof(type)</em> 产生以字节为单位存储对象或类型的存储尺寸。下面举例获取任何机器上 <em>int</em> 类型的存储尺寸： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace DataTypeApplication</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;Size of int : &#123;0&#125;&quot;,sizeof(int));</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size of int: 4</span><br></pre></td></tr></table></figure><h2 id="引用类型（Reference-types）"><a href="#引用类型（Reference-types）" class="headerlink" title="引用类型（Reference types）"></a>引用类型（Reference types）</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object obj;</span><br><span class="line">obj = 100; // 这是装箱</span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic &lt;variable_name&gt; = value;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic d = 20;</span><br></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;runoob.com&quot;;</span><br></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;runoob.com&quot;;</span><br></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = @&quot;C:\Windows&quot;;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;C:\\Windows&quot;;</span><br></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = @&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;/script&gt;&quot;;</span><br></pre></td></tr></table></figure><p>用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（Pointer-types）"><a href="#指针类型（Pointer-types）" class="headerlink" title="指针类型（Pointer types）"></a>指针类型（Pointer types）</h2><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char* cptr;</span><br><span class="line">int* iptr;</span><br></pre></td></tr></table></figure><p>我们将在章节”不安全的代码”中讨论指针类型。</p><h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C# 类型转换"></a>C# 类型转换</h1><p>类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型。在 C# 中，类型铸造有两种形式：</p><ul><li><strong>隐式类型转换</strong> - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。</li><li><strong>显式类型转换</strong> - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。</li></ul><p>下面的实例显示了一个显式的类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace TypeConversionApplication</span><br><span class="line">&#123;</span><br><span class="line">    class ExplicitConversion</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            double d = 5673.74;</span><br><span class="line">            int i;</span><br><span class="line"></span><br><span class="line">            // 强制转换 double 为 int</span><br><span class="line">            i = (int)d;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5673</span><br></pre></td></tr></table></figure><h2 id="C-类型转换方法"><a href="#C-类型转换方法" class="headerlink" title="C# 类型转换方法"></a>C# 类型转换方法</h2><p>C# 提供了下列内置的类型转换方法：</p><table><thead><tr><th>序号</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>ToBoolean</strong> 如果可能的话，把类型转换为布尔型。</td></tr><tr><td>2</td><td><strong>ToByte</strong> 把类型转换为字节类型。</td></tr><tr><td>3</td><td><strong>ToChar</strong> 如果可能的话，把类型转换为单个 Unicode 字符类型。</td></tr><tr><td>4</td><td><strong>ToDateTime</strong> 把类型（整数或字符串类型）转换为 日期-时间 结构。</td></tr><tr><td>5</td><td><strong>ToDecimal</strong> 把浮点型或整数类型转换为十进制类型。</td></tr><tr><td>6</td><td><strong>ToDouble</strong> 把类型转换为双精度浮点型。</td></tr><tr><td>7</td><td><strong>ToInt16</strong> 把类型转换为 16 位整数类型。</td></tr><tr><td>8</td><td><strong>ToInt32</strong> 把类型转换为 32 位整数类型。</td></tr><tr><td>9</td><td><strong>ToInt64</strong> 把类型转换为 64 位整数类型。</td></tr><tr><td>10</td><td><strong>ToSbyte</strong> 把类型转换为有符号字节类型。</td></tr><tr><td>11</td><td><strong>ToSingle</strong> 把类型转换为小浮点数类型。</td></tr><tr><td>12</td><td><strong>ToString</strong> 把类型转换为字符串类型。</td></tr><tr><td>13</td><td><strong>ToType</strong> 把类型转换为指定类型。</td></tr><tr><td>14</td><td><strong>ToUInt16</strong> 把类型转换为 16 位无符号整数类型。</td></tr><tr><td>15</td><td><strong>ToUInt32</strong> 把类型转换为 32 位无符号整数类型。</td></tr><tr><td>16</td><td><strong>ToUInt64</strong> 把类型转换为 64 位无符号整数类型。</td></tr></tbody></table><p>下面的实例把不同值的类型转换为字符串类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">namespace TypeConversionApplication</span><br><span class="line">&#123;</span><br><span class="line">    class StringConversion</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int i = 75;</span><br><span class="line">            float f = 53.005f;</span><br><span class="line">            double d = 2345.7652;</span><br><span class="line">            bool b = true;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(i.ToString());</span><br><span class="line">            Console.WriteLine(f.ToString());</span><br><span class="line">            Console.WriteLine(d.ToString());</span><br><span class="line">            Console.WriteLine(b.ToString());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">75</span><br><span class="line">53.005</span><br><span class="line">2345.7652</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-基本语法&quot;&gt;&lt;a href=&quot;#C-基本语法&quot; class=&quot;headerlink&quot; title=&quot;C#基本语法&quot;&gt;&lt;/a&gt;C#基本语法&lt;/h1&gt;&lt;p&gt;C# 是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种相互交互的对象组成。相同种类的对象通常
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(2)</title>
    <link href="http://yoursite.com/2018/06/23/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-2/"/>
    <id>http://yoursite.com/2018/06/23/C-学习之路-2/</id>
    <published>2018-06-23T07:28:31.000Z</published>
    <updated>2018-06-26T02:04:49.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C#程序结构"></a>C#程序结构</h1><h2 id="C-Hello-World-实例"><a href="#C-Hello-World-实例" class="headerlink" title="C# Hello World 实例"></a>C# Hello World 实例</h2><p>一个C#程序主要包括以下部分：</p><ul><li>命名空间声明(namespace declaration)</li><li>一个class</li><li>Class方法</li><li>Class属性</li><li>一个Main方法</li><li>语句（Statement）&amp;表达式（Expressions）</li><li>注释</li></ul><p>让我们看一个可以打印”Hello World“的简单的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace HelloWorldApplication</span><br><span class="line">&#123;</span><br><span class="line">    class HelloWorld</span><br><span class="line">    &#123;</span><br><span class="line">        static void main(string[] args) &#123;</span><br><span class="line">            /*我的第一个C#程序*/</span><br><span class="line">            Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码执行被编译和执行时，它会产生下列结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>让我们看看上面程序的各个部分：</p><ul><li>程序的第一行using System；-using 关键字用于在程序中包含System命名空间。一个程序一般有多个using语句。</li><li>下一行是namespace声明。一个namespace是一个系列的类。HelloWorldApplication命名空间包含了类HelloWorld。</li><li>下一行是class声明。类HelloWold包含了程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld类只有一个Main方法。</li><li>下一行定义了Main方法，是所有C#程序的入口点。Main方法说明当执行时，类将做什么动作。</li><li>下一行<code>/*...*/</code>被编译器忽略，且它会在程序中添加额外的注释。</li><li>Main方法通过语句Console.WriteLine（”Hello World“）；指定了它的行为。WriteLine是一个定义在System命名空间中的Console类的一个方法。该语句在屏幕上显示消息”Hello World“</li><li>最后一行Console.ReadKey()；是针对VS.NET用户的。这使得程序会等待一个按键的动作，防止程序从Visual Studio .NET启动时屏幕会快速运行并关闭.</li></ul><p>以下几点值得注意：</p><ul><li>C#是大小写敏感的。</li><li>所有的语句和表达式必须以分号结尾</li><li>程序执行是从Main方法开始的</li><li>与Java不同的是，文件名可以不同于类的名称</li></ul><h2 id="编译-amp-执行-C-程序"><a href="#编译-amp-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C# 程序"></a>编译 &amp; 执行 C# 程序</h2><p>如果您使用 Visual Studio.Net 编译和执行 C# 程序，请按下面的步骤进行：</p><ul><li>启动 Visual Studio。</li><li>在菜单栏上，选择 File -&gt; New -&gt; Project。</li><li>从模板中选择 Visual C#，然后选择 Windows。</li><li>选择 Console Application。</li><li>为您的项目制定一个名称，然后点击 OK 按钮。</li><li>新项目会出现在解决方案资源管理器（Solution Explorer）中。</li><li>在代码编辑器（Code Editor）中编写代码。</li><li>点击 Run 按钮或者按下 F5 键来运行程序。会出现一个命令提示符窗口（Command Prompt window），显示 Hello World。</li></ul><p>您也可以使用命令行代替 Visual Studio IDE 来编译 C# 程序：</p><ul><li>打开一个文本编辑器，添加上面提到的代码。</li><li>保存文件为 <strong>helloworld.cs</strong>。</li><li>打开命令提示符工具，定位到文件所保存的目录。</li><li>键入 <strong>csc helloworld.cs</strong> 并按下 enter 键来编译代码。</li><li>如果代码没有错误，命令提示符会进入下一行，并生成 <strong>helloworld.exe</strong> 可执行文件。</li><li>接下来，键入 <strong>helloworld</strong> 来执行程序。</li><li>您将看到 “Hello World” 打印在屏幕上。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-程序结构&quot;&gt;&lt;a href=&quot;#C-程序结构&quot; class=&quot;headerlink&quot; title=&quot;C#程序结构&quot;&gt;&lt;/a&gt;C#程序结构&lt;/h1&gt;&lt;h2 id=&quot;C-Hello-World-实例&quot;&gt;&lt;a href=&quot;#C-Hello-World-实例&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#学习之路(1)</title>
    <link href="http://yoursite.com/2018/06/23/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-1/"/>
    <id>http://yoursite.com/2018/06/23/C-学习之路-1/</id>
    <published>2018-06-23T06:51:46.000Z</published>
    <updated>2018-06-23T07:46:27.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C# 是一个简单的、现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的。</p><p>本教程将告诉您基础的 C# 编程，同时将向您讲解 C# 编程语言相关的各种先进理念。</p><h2 id="谁适合阅读本教程？"><a href="#谁适合阅读本教程？" class="headerlink" title="谁适合阅读本教程？"></a>谁适合阅读本教程？</h2><p>本教程有助于初学者理解基础的 C# 编程。在学习完本教程后，您将到达一个中级的 C# 编程水平。</p><h2 id="阅读本教程前，您需要了解的知识："><a href="#阅读本教程前，您需要了解的知识：" class="headerlink" title="阅读本教程前，您需要了解的知识："></a>阅读本教程前，您需要了解的知识：</h2><p>C# 编程是基于 C 和 C++ 编程语言的，因此如果您对 C 和 C++ 编程有基本的了解，将有助于您学习 C# 编程语言。</p><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译/执行 C# 程序"></a>编译/执行 C# 程序</h2><p>菜鸟教程提供了在线的 C# 在线编译环境，您只需进行简单的点击动作，即可在高端的服务器上体验真实的编程经验。这是完全免费的在线工具。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace HelloWorldApplication</span><br><span class="line">&#123;</span><br><span class="line">    /* 类名为 HelloWorld */</span><br><span class="line">    class HelloWorld</span><br><span class="line">    &#123;</span><br><span class="line">        /* main函数 */</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            /* 我的第一个 C# 程序 */</span><br><span class="line">            Console.WriteLine(&quot;Hello World!&quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-有用的资源"><a href="#C-有用的资源" class="headerlink" title="C# 有用的资源"></a>C# 有用的资源</h2><p>本教程列出了 C# 网站、书籍和文章。</p><h3 id="C-有用的网站"><a href="#C-有用的网站" class="headerlink" title="C# 有用的网站"></a>C# 有用的网站</h3><ul><li><a href="http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx" target="_blank" rel="noopener">C# Programming Guide</a> - 介绍了有关关键的 C# 语言特征以及如何通过 .NET 框架访问 C# 的详细信息。</li><li><a href="http://www.microsoft.com/visualstudio/eng/downloads" target="_blank" rel="noopener">Visual Studio</a> - 下载作为 C# 集成开发环境的 Visual Studio 的最新版本。</li><li><a href="http://www.mono-project.com/Main_Page" target="_blank" rel="noopener">Go Mono</a> - Mono 是一个允许开发人员简单地创建跨平台应用程序的软件平台。</li><li><a href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language" target="_blank" rel="noopener">C Sharp (programming language) </a>)- 维基百科解释 C#（编程语言）。</li></ul><h1 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h1><p>C#是一个现代的、通用的、面向对象的编程语言，它是由微软(Microsoft)开发的，由Ecma和ISO标准认可的。</p><p>C# 是由 Anders Hejlsberg 和他的团队在 .Net 框架开发期间开发的。</p><p>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。</p><p>下面列出了 C# 成为一种广泛应用的专业语言的原因：</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><h2 id="C-强大的编程功能"><a href="#C-强大的编程功能" class="headerlink" title="C# 强大的编程功能"></a>C# 强大的编程功能</h2><p>虽然 C# 的构想十分接近于传统高级语言 C 和 C++，是一门面向对象的编程语言，但是它与 Java 非常相似，有许多强大的编程功能，因此得到广大程序员的青睐。</p><p>下面列出 C# 一些重要的功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li>委托（Delegates）和事件管理（Events Management）</li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><h1 id="C-环境"><a href="#C-环境" class="headerlink" title="C#环境"></a>C#环境</h1><h2 id="Net-框架（-Net-Framework）"><a href="#Net-框架（-Net-Framework）" class="headerlink" title=".Net 框架（.Net Framework）"></a>.Net 框架（.Net Framework）</h2><p>.Net 框架是一个创新的平台，能帮您编写出下面类型的应用程序：</p><ul><li>Windows 应用程序</li><li>Web 应用程序</li><li>Web 服务</li></ul><p>.Net 框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。</p><p>.Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件：</p><ul><li>公共语言运行库（Common Language Runtime - CLR）</li><li>.Net 框架类库（.Net Framework Class Library）</li><li>公共语言规范（Common Language Specification）</li><li>通用类型系统（Common Type System）</li><li>元数据（Metadata）和组件（Assemblies）</li><li>Windows 窗体（Windows Forms）</li><li>ASP.Net 和 ASP.Net AJAX</li><li>ADO.Net</li><li>Windows 工作流基础（Windows Workflow Foundation - WF）</li><li>Windows 显示基础（Windows Presentation Foundation）</li><li>Windows 通信基础（Windows Communication Foundation - WCF）</li><li>LINQ</li></ul><h2 id="C-的集成开发环境（Integrated-Development-Environment-IDE）"><a href="#C-的集成开发环境（Integrated-Development-Environment-IDE）" class="headerlink" title="C# 的集成开发环境（Integrated Development Environment - IDE）"></a>C# 的集成开发环境（Integrated Development Environment - IDE）</h2><p>微软（Microsoft）提供了下列用于 C# 编程的开发工具：</p><ul><li>Visual Studio 2010 (VS)</li><li>Visual C# 2010 Express (VCE)</li><li>Visual Web Developer</li></ul><p>后面两个是免费使用的，可从微软官方网址下载。使用这些工具，您可以编写各种 C# 程序，从简单的命令行应用程序到更复杂的应用程序。您也可以使用基本的文本编辑器（比如 Notepad）编写 C# 源代码文件，并使用命令行编译器（.NET 框架的一部分）编译代码为组件。</p><p>Visual C# Express 和 Visual Web Developer Express 版本是 Visual Studio 的定制版本，且具有相同的外观和感观。它们保留 Visual Studio 的大部分功能。在本教程中，我们使用的是 Visual C# 2010 Express。</p><p>您可以从 <a href="https://www.visualstudio.com/zh-hans/downloads/" target="_blank" rel="noopener">Microsoft Visual Studio</a> 上进行下载。它会自动安装在您的机器上。请注意，您需要一个可用的网络连接来完成速成版的安装。</p><h2 id="在-Linux-或-Mac-OS-上编写-C-程序"><a href="#在-Linux-或-Mac-OS-上编写-C-程序" class="headerlink" title="在 Linux 或 Mac OS 上编写 C# 程序"></a>在 Linux 或 Mac OS 上编写 C# 程序</h2><p>虽然 .NET 框架是运行在 Windows 操作系统上，但是也有一些运行于其它操作系统上的版本可供选择。<strong>Mono</strong> 是 .NET 框架的一个开源版本，它包含了一个 C# 编译器，且可运行于多种操作系统上，比如各种版本的 Linux 和 Mac OS。如需了解更多详情，请访问 <a href="http://www.mono-project.com/download/stable/" target="_blank" rel="noopener">Go Mono</a>。</p><p>Mono 的目的不仅仅是跨平台地运行微软 .NET 应用程序，而且也为 Linux 开发者提供了更好的开发工具。Mono 可运行在多种操作系统上，包括 Android、BSD、iOS、Linux、OS X、Windows、Solaris 和 UNIX。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C# 是一个简单的、现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的。&lt;/p&gt;
&lt;p&gt;本教程将告诉您基础的 C# 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识积累-计算属性和侦听器</title>
    <link href="http://yoursite.com/2018/06/21/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/21/Vue的知识积累-计算属性和侦听器/</id>
    <published>2018-06-21T13:26:33.000Z</published>
    <updated>2018-06-21T13:40:59.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><hr><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"example"</span>&gt;</span></span><br><span class="line">     &#123;&#123;message.split('').reverse().join('')&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a><a href="https://cn.vuejs.org/v2/guide/computed.html#%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">基础例子</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><p>Original message: “Hello”</p><p>Computed reversed message: “olleH”</p><p>这里我们声明了一个计算属性 <code>reversedMessage</code>。我们提供的函数将用作属性 <code>vm.reversedMessage</code> 的 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'olleH'</span></span><br><span class="line">vm.message = <span class="string">'Goodbye'</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'eybdooG'</span></span><br></pre></td></tr></table></figure><p>你可以打开浏览器的控制台，自行修改例子中的 vm。<code>vm.reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值。</p><p>你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</p><p> <a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">计算属性缓存 vs 方法</a></p><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的依赖进行缓存的</strong>。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code>计算属性会立即返回之前的计算结果，而不必再次执行函数。</p><p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong> 。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p><h3 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a><a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">计算属性 vs 侦听属性</a></h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 <code>watch</code>——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 <code>watch</code> 回调。细想一下这个例子： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码是命令式且重复的。将它与计算属性的版本进行比较： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>好得多了，不是吗？ </p><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a><a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84-setter" target="_blank" rel="noopener">计算属性的 setter</a></h3><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code>也会相应地被更新。 </p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><hr><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 例如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#watch-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">''</span>,</span><br><span class="line">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">      <span class="keyword">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 <code>watch</code> 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>除了 <code>watch</code> 选项之外，您还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch API</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算属性和侦听器&quot;&gt;&lt;a href=&quot;#计算属性和侦听器&quot; class=&quot;headerlink&quot; title=&quot;计算属性和侦听器&quot;&gt;&lt;/a&gt;计算属性和侦听器&lt;/h1&gt;&lt;h2 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue的知识点积累-模板语法</title>
    <link href="http://yoursite.com/2018/06/21/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/21/Vue的知识点积累-模板语法/</id>
    <published>2018-06-21T13:10:34.000Z</published>
    <updated>2018-06-25T02:52:06.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">直接写渲染 (render) 函数</a>，使用可选的 JSX 语法。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><hr><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">文本</a></h3><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message:&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> 属性的值。无论何时，绑定的数据对象上 <code>msg</code> 属性发生了改变，插值处的内容都会更新。</p><p>通过使用 <a href="https://cn.vuejs.org/v2/api/#v-once" target="_blank" rel="noopener">v-once 指令</a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8E%9F%E5%A7%8B-HTML" target="_blank" rel="noopener">原始 HTML</a></h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <code>v-html</code> 指令： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>span</code> 的内容将会被替换成为属性值 <code>rawHtml</code>，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E7%89%B9%E6%80%A7" target="_blank" rel="noopener">特性</a></h3><p>Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 <a href="https://cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener">v-bind 指令</a>： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布尔特性的情况下，它们的存在即暗示为 <code>true</code>，<code>v-bind</code> 工作起来略有不同，在这个例子中： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> 特性甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。 </p><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E4%BD%BF%E7%94%A8-JavaScript-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">使用 JavaScript 表达式</a></h3><p>迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><hr><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊特性。指令特性的值预期是<strong>单个 JavaScript 表达式</strong>(<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素。 </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">参数</a></h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML 特性：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> 特性与表达式 <code>url</code> 的值绑定。</p><p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里参数是监听的事件名。我们也会更详细地讨论事件处理。 </p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">修饰符</a></h3><p>修饰符 (Modifiers) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在接下来对 <a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener"><code>v-on</code></a> 和 <a href="https://cn.vuejs.org/v2/guide/forms.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener"><code>v-for</code></a> 等功能的探索中，你会看到修饰符的其它例子。 </p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><hr><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue.js 管理所有模板的<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener">单页面应用程序 (SPA - single page application)</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue.js 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写： </p><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99" target="_blank" rel="noopener"><code>v-bind</code> 缩写</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99" target="_blank" rel="noopener"><code>v-on</code> 缩写</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于特性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模板语法&quot;&gt;&lt;a href=&quot;#模板语法&quot; class=&quot;headerlink&quot; title=&quot;模板语法&quot;&gt;&lt;/a&gt;模板语法&lt;/h1&gt;&lt;p&gt;Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.
      
    
    </summary>
    
    
  </entry>
  
</feed>
